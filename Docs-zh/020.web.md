# System.Web

`System.Web`是**PLoop**提供的独立的类库，需要单独`require "PLoop.System.Web"`来加载，它提供了和平台无关的Web框架。系统目前只支持UTF-8编码。具体实现需要针对平台来提供。

目前的实现有: 对应[Openresty][]服务器的[NgxLua][]，例子可以参考[PLoop.Browser][]，用于通过反射机制展示**PLoop**的类库。


## 目录

* [测试环境](#测试环境)
* [Web APP - System.Web.Application](#systemwebapplication)
    * [Web App的初始化](#web-app的初始化)
    * [nginx.conf配置](#nginx_conf配置)
    * [init.lua初始化](#init_lua初始化)
    * [我们的第一个Web App](#我们的第一个Web-App)
    * [__Route__ 路由管理](#__Route__-路由管理)
    * [`System.Web.__Text__`](#systemweb__text__)
    * [`System.Web.__Json__`](#systemweb__json__)
    * [`System.Web.__Redirect__`](#systemweb__redirect__)
    * [`System.Web.__View__`](#systemweb__view__)
    * [`System.Web.__Switch__`](#systemweb__switch__)
    * [`System.Web.__File__`](#systemweb__file__)
    * [Application的定义](#Application的定义)
        * [Web App作为子网站](#Web-App作为子网站)
        * [Web App的错误处理](#Web-App的错误处理)
* [Web 常量](#Web-常量)
* [编码和解码](#编码和解码)
* [上下文 - System.Web.HttpContext](#上下文---systemwebhttpcontext)
    * [请求 - System.Web.HttpRequest](#请求---systemwebhttprequest)
    * [响应 - System.Web.HttpResponse](#响应---systemwebhttpresponse)
    * [Cookie管理 - System.Web.HttpCookie & System.Web.HttpCookies](#Cookie管理---systemwebhttpcookie--systemwebhttpcookies)
    * [用户会话 - System.Web.HttpSession](#用户会话---systemwebhttpsession)
        * [System.Web.ISessionIDManager](#systemwebisessionidmanager)
            * [System.Web.GuidSessionIDManager](#systemwebguidsessionidmanager)
            * [NgxLua.JWTSessionIDManager](#ngxluajwtsessionidmanager)
        * [System.Web.ISessionStorageProvider](#systemwebisessionstorageprovider)
            * [System.Web.TableSessionStorageProvider](#systemwebtablesessionstorageprovider)
            * [NgxLua.ShareSessionStorageProvider](#ngxluasharesessionstorageprovider)
            * [NgxLua.RedisSessionStorageProvider](#ngxluaredissessionstorageprovider)
            * [NgxLua.JWTSessionStorageProvider](#ngxluajwtsessionstorageprovider)
* [页面渲染](#页面渲染)
    * [路由和资源文件](#路由和资源文件)
    * [Lua Server Page (.lsp)](#lua-server-page-lsp)
    * [Master Page (.master)](#master-page-master)
    * [超类Web部件](#超类Web部件)
    * [混合Lua代码](#混合Lua代码)
        * [Block](#block)
        * [Inline](#inline)
        * [Full-line](#full-line)
        * [Mixed Method](#mixed-method)
    * [Helper Page (.helper)](#helper-page-helper)
    * [Embed Page (.embed)](#embed-page-embed)
    * [Inner Request Page](#inner-request-page)
    * [Lua Code file (.lua)](#lua-code-file-lua)
* [MVC框架 - System.Web.MVC](#MVC框架---systemwebmvc)
    * [路由管理](#路由管理)
    * [控制器 - System.Web.Controller](#控制器---systemwebcontroller)
    * [数据 - Model](#数据---model)
* [表单验证](#表单验证)
* [用户认证](#用户认证)
    * [登录验证](#登录验证)
    * [权限认证](#权限认证)
* [内部请求验证](#内部请求验证)
* [Http上下文请求处理流程](#Http上下文请求处理流程)
* [错误处理](#错误处理)
* [相对路径和绝对路径](#相对路径和绝对路径)
* [视图的配置](#视图的配置)
* [自定义渲染引擎](#自定义渲染引擎)


## 测试环境

**PLoop**提供的Web框架是平台无关的，但为了更容易展现框架功能，我们选择[Openresty][]作为测试平台，目前只有[NgxLua][]针对[Openresty][]提供了**PLoop** Web框架的实现。如果期望在特定服务器上实现，可以参考[NgxLua][]，实际并不复杂。

测试环境采用的软件环境是(CentOS7 + Mysql 8 + Redis + Openresty)：

1. CentOS 7，请到[centos.org](http://isoredirect.centos.org/centos/7/isos/x86_64/)，下载，作为测试环境，推荐使用[Oracle VM VirtualBox](https://www.virtualbox.org/)创建虚拟机，进行最小安装即可。

    如果采用虚拟机的话，配置时，网卡需要开启两个，一个是NAT网络，用于访问外网，另一个是Host-Only网络，这样主机可以直接通过IP访问虚拟机内开启的Web服务器。

    首次进入系统后，最好检查下/etc/sysconfig/network-scripts/ifcfg-enp0s8文件，可以使用vi编辑，确保`ONBOOT=yes`，开机加载。最好固定IP地址(IPADDR)，方便主机访问。

    **为了简单起见，下述操作都使用root账号进行，权限管理不会涉及**。


2. 服务器采用[Openresty][]，安装可以参考[Openresty的安装](https://openresty.org/cn/installation.html)，也可以直接尝试下面的操作：

    ```shell
    yum install yum-utils
    yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo
    yum install openresty
    yum install openresty-resty
    ```

    正常安装后，将路径添加到PATH，也可以写入~/.bashrc or ~/.bash_profile文件，确保开机加载

    ```shell
    export PATH=/usr/local/openresty/bin:/usr/local/openresty/nginx/sbin:$PATH
    ```

    测试下面的命令，如果能正确输出，说明安装正常，路径配置也正常了。

    ```shell
    resty -e 'print("hello, world")'
    ```

    新装的系统可能没开放80端口，需要先开启

    ```shell
    firewall-cmd --zone=public --add-port=80/tcp --permanent
    ```

3. 数据库采用Mysql 8.0，从[Mysql官网](https://dev.mysql.com/downloads/repo/yum/)可以查询最新的对应CentOS 7的版本，也可以采用下面的操作：

    安装Mysql 8.0，并设置开机启动

    ```shell
    yum install wget
    cd /tmp

    wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm
    md5sum mysql80-community-release-el7-3.noarch.rpm
    rpm -ivh mysql80-community-release-el7-3.noarch.rpm
    yum install mysql-server -y
    systemctl start mysqld
    systemctl status mysqld
    ```

    查看root@localhost的临时密码

    ```shell
    grep 'temporary password' /var/log/mysqld.log

    mysql -u root -p
    ```

    获取的临时密码等候就可以修改root密码，添加实际用户，这里简单创建一个具有所有权限的admin:

    ```sql
    ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';
    CREATE USER 'admin'@'%' IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY '管理员密码';
    GRANT ALL PRIVILEGES ON * . * TO 'admin'@'%';
    FLUSH PRIVILEGES;
    ```

    之后创建一个新的`PLoop`数据库，用于测试。

    ```sql
    CREATE DATABASE PLoop;
    EXIT
    ```


4. 缓存数据库使用[Redis](https://github.com/antirez/redis)，可以在网站中拿去最新的版本，下面安装以5.0.6版为准：

    ```shell
    cd /usr/local
    mkdir redis
    cd redis

    wget https://github.com/antirez/redis/archive/5.0.6.tar.gz
    tar -zxvf 5.0.6.tar.gz

    yum install gcc
    cd redis-5.0.6

    make
    cd src
    make install
    ```

    安装后需要配置开机启动

    ```shell
    cdd /etc
    mkdir redis
    cp /usr/local/redis/redis-5.0.6/utils/redis_init_script /etc/init.d/redisd
    cp /usr/local/redis/redis-5.0.6/redis.conf /etc/redis/6379.conf
    vi /etc/redis/6379.conf
    ```

    最后一行是编辑6379.conf文件，找到里面的`daemonize=no`，需要修改为yes，然后保存退出。

    启动redis服务:

    ```shell
    service redisd start
    ```

    那么默认我们的Redis服务器运本地127.0.0.1的6379端口。

5. 针对使用[Oracle VM VirtualBox](https://www.virtualbox.org/)的用户，可以通过共享文件夹的形式，在Windows系统中编写代码，CentOS 7共享该目录，可以比较直接的运行整个网站，在开启Debug模式时，Windows上编辑代码文件，变更也会即时反映在CentOS上运行的网站上。

    首先需要选择安装的虚拟机，点击设置-共享文件夹，然后添加一个本地目录作为共享目录，分配名称为www（可自行修改），选择自动挂载。确定即可。

    然后，启动虚拟机，在虚拟机的界面，选择设备-安装增强功能，这样VBox会挂载一个iso，等待安装。

    准备工作

    ```shell
    yum update
    yum install gcc kernel-devel make

    reboot
    ```

    安装VBox增强功能。

    ```shell
    mkdir /cdrom
    mount /dev/cdrom /cdrom

    /cdrom/VBoxLinuxAdditions.run
    ```

    加载共享目录到 ~/www，为了方便，创建一个start.sh命令文件用于启动nginx，创建一个reload.sh命令文件用于重启nginx

    ```shell
    cd ~
    mkdir www
    mount -t vboxsf www ~/www/

    cat > start.sh <<EOF
    mount -t vboxsf www ~/www/
    cd www
    nginx -p `pwd`/www -c conf/nginx.conf
    EOF

    cat > reload.sh <<EOF
    cd www
    nginx -p `pwd`/www -s stop
    nginx -p `pwd`/www -c conf/nginx.conf
    EOF

    chmod +x start.sh
    chmod +x reload.sh
    ```

    之后，程序部署到共享目录后，通过

    ```shell
    cd ~
    ./start.sh
    ```

    启动网站，通过

    ```shell
    cd ~
    ./reload.sh
    ```

    来重启网站，到此我们测试环境的准备工作就完成了。**之后所有提及的文件路径，都以这个共享文件夹为根路径**。


## Web App - System.Web.Application

### Web App的初始化

一个Web App(`System.Web.Application`类的对象)是一个单独的web服务，一个`nginx`服务可以运行多个Web App，每个App会具有自己独立的配置，路由，控制器等等。首先我们构建一个Web App然后在我们的测试环境中启动它:

简单起见，以下初始化操作在CentOS中完成，分别是拷贝默认的nginx配置以及下载**PLoop**及**NgxLua**两个库:

```shell
cd ~/www/
mkdir conf
cp /usr/local/openresty/nginx/conf/* ~/www/conf

yum install git -y

git clone https://github.com/kurapica/PLoop
git clone https://github.com/kurapica/NgxLua
```

### nginx.conf配置

之后打开/conf/nginx.conf文件（以后的文件编辑操作可以在windows上完成，或者任意你习惯的编辑方式），将内容替换为:

```conf
user root;

pid logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include mime.types;

    lua_shared_dict plbr_session_storage 10m;
    lua_shared_dict ngxlua_file_lock 100k;

    lua_package_path "${prefix}?.lua;${prefix}?/init.lua;/usr/local/openresty/lualib/?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua";

    init_by_lua_file ./conf/init.lua;

    server{
        listen       80;
        server_name  localhost;

        location / {
            root html;

            # MIME type determined by default_type:
            default_type 'text/html';

            content_by_lua ' PLBR.HttpContext():Process() ';
        }
    }
}
```

user选择root是简单的避免权限问题，实际项目请自行管理权限设置。上面定义了两个共享表，`plbr_session_storage`用于保存用户会话状态，`ngxlua_file_lock`用于提供全局锁的机制，例如加载代码，或者网页模板时，需要加锁，避免同时多个类生成，产生冲突。但一般加载后，除非文件变更需要重载，是不需要再使用全局锁的，所有不会影响服务器的高并发。具体使用在多线程环节介绍。

`lua_package_path`制定了Lua加载库的路径，`${prefix}`是网站的根路径，即 `~/www/`，所以，保存在它下面的**PLoop**和**NgxLua**都可以被正常加载，后面的是[Openresty][]随附的Lua库。基本是常用库。

`init_by_lua_file`指明了启动nginx时，初始化用的Lua文件，通常我们在这个文件中，加载**PLoop**和**NgxLua**库，然后加载各个Web App。

这里我们只加载一个用于测试的Web App，所以，只定义一个server，其中`content_by_lua`是我们处理的入口，其中`PLBR`是我们将要申明的命名空间，通常一个Web APP应该具有一个独立的命名空间，`PLBR.HttpContext`是一个上下文对象，为了在多OS线程平台上使用Lua，我们通常需要一个上下文对象来隔离处理，由上下文对象启动Http请求的处理，这个过程中创建的所有对象都可以在上下文对象中读写值，因为单个系统线程中的Lua操作实际是单线程，所以，这些对象可以没有冲突的通过上下文对象共享值。稍后会详细介绍上下文对象。


### init.lua初始化

创建`/conf/init.lua`文件，这里我们将加载网站的基础代码部分，主要是加载类库和加载Web App，但Web App具体实现会在稍后再定义：

```lua
PLOOP_PLATFORM_SETTINGS = { CORE_LOG_LEVEL = 3, THREAD_POOL_CONTEXT_ONLY = true, TYPE_VALIDATION_DISABLED = false, THREAD_SAFE_ITERATOR = true }

-- NgxLua会加载PLoop
require "NgxLua"

-- 全局配置，不限定哪个Web App
PLoop(function(_ENV)
    -----------------------------------------------------------------------
    --                            全局Web配置                            --
    -----------------------------------------------------------------------
    Web.Config      = {
        Debug       = true,
        LogLevel    = System.Logger.LogLevel.Debug,
    }

    -----------------------------------------------------------------------
    --                            线程锁管理器                            --
    -----------------------------------------------------------------------
    NgxLua.LockManager("ngxlua_file_lock")
end)

-- 加载Web App，可以按顺序加载多个
require "plbr"
```

注意，这里通过`PLOOP_PLATFORM_SETTINGS`将`THREAD_POOL_CONTEXT_ONLY`置为true，确保每个Http请求事务独享协程池，避免冲突。`Web.Config`是Web框架的全局配置，不涉及单个Web App，这里的`Debug`设置为true，那么当资源文件类似网站模板文件修改后，再次访问时，系统会重新加载，这可以比较即时的看到修改结果。但因为需要检查文件修改时间，并且因为资源文件间存在依赖关系（子类，超类），检查文件的数量可能会比较多，仅仅适用于开发阶段，**实施时请务必修改为false**。

`NgxLua.LockMananger`是使用[Openresty][]提供的共享表来实现线程锁，它没有太多的可以配置的属性，基本保持这样的申明处理即可。这里使用的`ngxlua_file_lock`是在`nginx.conf`中申明的。


**请特别注意开启THREAD_SAFE_ITERATOR选项，因为Openresty协程执行稍有不同，不开启时，迭代器出错时，可能会导致无限返回 cannot resume dead coroutine 的问题。**



### 我们的第一个Web App

创建`/plbr/`目录，这个目录将是我们实际的项目代码目录，首先创建`/plbr/init.lua`文件，这个文件将保存我们在初始化时需要加载的所有文件。这些文件通常是路由，模型，常用类型等的定义。这些必须在初始化时加载，并且系统无法在运行过程中重新加载（使用上面的`./reload.sh`来重新初始化整个网站）。

在这个文件中，我们将初始化我们的Web App，并加载一个路由文件。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    -- 定义PLBR.HttpContext，它继承了NgxLua.HttpContext
    -- 唯一功能是构造时，绑定自己的Application为当前的Web App
    -- 注意，Application继承了`System.Module`，所以可以作为
    -- 环境使用，这里的 _ENV 就是 Application "PLBR"
    --
    -- 请重点注意，上下文仅仅是作为请求执行的容器，类似路由，
    -- 控制器等等实际处理都是归属于特定的Web App的，所以，
    -- 每个Http上下文对象都需要关联一个Web App，才能进行实际处理
    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }
end)

-- 保存PLBR到_G
import "PLBR"

-- 加载路由文件
require "plbr.route"
```

`Application`是由Web框架保存到`_G`的类，它继承了`System.Module`，所以可以作为环境使用，也提供了树状的代码管理机制（虽然很少需要这么使用）。在它里面，我们申明了`PLBR`命名空间，注意和Web App区分开来。之后定义了独属于这个Web App的Http上下文类，实际就是将它的对象和这个Web App进行绑定。

之后在`nginx.conf`文件的`content_by_lua`中，我们就是构建了这个上下文类的对象，然后调用`Process`方法启动请求的执行处理。这里的部分实际并不涉及具体的业务逻辑，因为根据请求url的不同，我们需要进行的处理都不相同，那么首先我们需要能根据url对请求进行分发，第一步，我们需要一个路由文件进行管理。

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    -- 所有属于PLBR这个Web App的配置，资源都需要定义在这个Web App环境中

    __Route__("/")
    __Text__() function hello(context)
        return "Hello world"
    end
end)
```

保存后，启动服务器(初次需要创建一个logs目录)

```shell
cd ~/www/
mkdir logs
cd ~
./start.sh
```

如果启动过，用`./reload.sh`。

然后可以打开浏览器，输入虚拟机地址(ip addr，VBOX的话，一般是192.168.56.xx)或你的服务器地址直接访问，或者CentOS中使用

```shell
curl http://localhost
```

就可以看到输出结果是`Hello world`。这样，我们的测试环境就正式可以使用了。可以看到，虽然之前做了很多铺垫，但实际业务逻辑相当简单。路由，输出方式和保存有业务逻辑的函数绑定，我们可以使用路由完成所有的Web API创建的工作，不过这只是基础部分，通常并不会将主要业务放在路由中直接处理，而是使用MVC中控制器来处理业务，稍后会看到详细的介绍。

后面单独列出Url地址时，会形如 `/test`，没有特殊说明请自行拼接为`http://localhost/test`，或指定的IP的形式`http://192.168.56.xx/test`。

### __Route__ 路由管理

用户通过url访问网站的不同区域和功能，为了将请求分发给对应的请求处理流程，我们需要进行路由管理，一个路由通常由两部分组成，首先是匹配请求url使用的路由字符串，可以是精确匹配用，也可以是作为模式字符串去匹配:

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/hello")
    __Text__() function hello(context)
        return "Hello world"
    end

    __Route__ ".*" __Text__()
    function parsetype(context)
        local target = context.Request.Url:gsub("/", "."):sub(2, -1) -- /System/Threading -> System.Threading
        local ns = Namespace.GetNamespace(target)

        if ns then
            return target .. " is " .. tostring(getmetatable(ns))
        else
            return target .. " isn't a type"
        end
    end
end)
```

请使用`./reload.sh`重启服务器查看结果，路由管理属于初始化的部分，并非动态加载，所以，我们需要重启服务器来查看修改。然后我们可以测试:

* GET /hello  - Hello world

* GET /HELLO  - Hello world

* GET /System/NoneExist - System.NoneExist isn't a type

* GET /System/Collections/List - System.Collections.List is class

这里使用了两种路由路径，第一种类似`/hello`，没有正则表达式，这类是静态路由，另一类是类似`.*`, `/test/*.lsp`这样具有模式字符串的动态路由。

当任意请求进入时，会先以大小写无视的规则去匹配静态路由，这个匹配实际是利用Lua的哈希表完成，所以，无论多少静态路由，都只有1到2次查询。如果匹配成功，就将请求交给对应的流程进行处理。

如果无法匹配静态路由，系统将根据动态路由的注册顺序，进行匹配，所以，上面定义的第二个路由虽然能匹配所有请求，但它不会被用于处理`/hello`的请求。

`__Route__`并不是只能用于绑定的路径，它实际的构造体函数是

```lua
__Route__(String, HttpMethod/HttpMethod.ALL, Boolean/true)
```

第一个参数是访问路径，第二个参数的类型是`HttpMethod`，这个枚举类型包含了所有的Http方法，详见[Web 常量](#Web-常量)，最后一个参数是路由是否无视大小写，默认是true，所有上面的`/HELLO`也会被`/hello`匹配。通常很少需要调整第三个参数，重点在于第二个:

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/test", HttpMethod.GET) __Text__()
    function getTest(context)
        return "GET TEST"
    end

    __Route__("/test", HttpMethod.POST) __Text__()
    function postTest(context)
        return "POST TEST"
    end
end)
```

这个测试适合用curl进行

```shell
curl http://localhost/test
curl http://localhost/test -X POST
```

测试可以得到两个不同的返回结果，这样同一个WEB API接口，我们可以组合`HttpMethod`来完成不同的操作。

路由本身并不处理请求，我们定义路由只是为了给一个Web APP生成一套路由，然后请求传给这个Web App后，路由管理器根据注册的路由将请求分发给各个处理流程。

上述的路由处理中，都伴随使用了`__Text__`特性，这个特性将函数封装为一个处理流程对象，这个函数的返回值将作为请求结果，按照`text/plain`输出。

下面详细介绍这些特性。


### `System.Web.__Text__`

如上面的例子所述，`__Text__`特性用于将函数封装为绑定给路由的请求处理流程对象，函数的返回值将以`text/plain`类型输出给客户端。除了上面例子中的简单模式外，也支持迭代器的形式，分多次输出文本给客户端：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/multitext", HttpMethod.GET)
    __Text__() __Iterator__()
    function MultiText(context)
        coroutine.yield("This is part of the result\n")
        coroutine.yield("This is another part of the result\n")
    end
end)
```

重启服务器后，访问`GET /multitext`可以看到效果。两端文本都正常输出了。


### `System.Web.__Json__`

`__Json__`特性用于将函数封装为绑定给路由的请求处理流程对象，函数的返回值将以`application/json`的形式，序列化后传给客户端：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/data")
    __Json__() function getData(context)
        local data = {}

        for k, v in pairs(_G) do
            if type(v) == "table" and getmetatable(v) == nil then
                local item = {}

                for j, l in pairs(v) do
                    if type(l) == "function" then
                        item[#item + 1] = j
                    end
                end

                data[k] = item
            end
        end

        return data
    end
end)
```

访问`GET /data`可以看到结果，它将`_G`内所有值是table的键值对保存下来，然后将table内的包含的函数的名字都保存为一个数组，这点可以在显示结果中看到。


### `System.Web.__Redirect__`

`__Redirect__`特性用于根据返回值重定向url，

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/text")
    __Text__() function gettext(context)
        return "Hello"
    end

    __Route__("/redirect")
    __Redirect__() function redirect(context)
        return "/text"
    end
end)
```

之后使用浏览器访问`GET /redirect`即可看到地址栏被重定向了。（localhost记得改成IP地址）


### `System.Web.__View__`

`__View__`特性相对上面的特性较为复杂，它会同时注册一个视图模板或者模板文件，模板将会被生成为一个视图类，业务函数的处理结果将作为初始化表（如果提供）用于构造视图类的对象，之后视图类会渲染出网页内容提供给客户端：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/index")
    __View__ "index.view" [[
        <html>
            <head>
                <title>@self.title</title>
            </head>
            <body>
                <p>@self.welcome</p>
            </body>
        </html>
    ]]
    function index(context)
        -- 上下文使用介绍稍后有更详细的说明
        local name = context.Request.QueryString.name

        return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
    end
end)
```

访问`GET /index?name=Ann`结果为

```html
<html>
    <head>
        <title>Hi Ann</title>
    </head>
    <body>
        <p>Welcome here, Ann</p>
    </body>
</html>
```

`__View__`特性实际主要是用于绑定模板文件，模板文件都有类似`.view`这样的后缀名，这种文件都是[资源文件](017.io.resource.md)，根据后缀，系统会使用不同的资源加载器去加载这些文件，这也是为什么上面的例子中，除了HTML模板，还需要提供一个文件名，这个文件名的名字将作为生成的视图类的类名，而后缀名决定了系统如何加载这份模板。

`.view`文件的具体加载规则稍后详细介绍，现在先集中在`__View__`这个特性上。通常来说，路由文件的修改需要重启服务器，但资源文件当开启Debug模式时，是可以随时修改查看修改效果的。我们将上面的例子修改为


```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/index")
    __View__ "/view/index.view"
    function index(context)
        -- 上下文使用介绍稍后有更详细的说明
        local name = context.Request.QueryString.name

        return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
    end
end)
```

注意，因为这里需要指定文件路径，请务必使用绝对路径，通常我们的资源文件有多种，最好通过目录分开，所以，这里给了一个`view`目录。

另外请注意nginx.conf中设置了root为html目录，我们的资源文件也是以/html目录为根目录，所以，实际视图模板需要保存在`~/www/html/view/index.view`目录下，后面的资源文件类似，省略掉`~/www`部分。

然后创建第一个视图模板文件:

```html
<!-- /html/view/index.view -->
<html>
    <head>
        <title>@self.title</title>
    </head>
    <body>
        <p>@self.welcome</p>
    </body>
</html>
```

首先重启服务器后，再次访问`GET /index?name=Ann`，一切正常后，修改这个模板文件为:

```html
<!-- /html/view/index.view -->
<html>
    <head>
        <title>@self.title</title>
    </head>
    <body>
        <p>A modify version</p>
        <p>@self.welcome</p>
    </body>
</html>
```

刷新页面，可以看到输出结果已经改变了。类似视图模板文件这样的资源文件都是可以在开发中随时修改，随时看到效果的。

虽然因为我们现在的业务逻辑保存在路由文件中，导致修改业务需要重启服务器，但后面引入的MVC框架会彻底解决这些问题。包括目前每个函数处理结果的返回方式固定的问题，在MVC中都会被很好的解决掉。

回到`__View__`特性，我们并不需要在申明这个特性时，指定模板文件，如果不指定模板文件，那么它会将函数的第一个返回值作为模板路径，第二个值作为构造模板对应视图类的初始表(即便指定了模板文件，如果第一个返回值是字符串，也会作为新的模板路径使用）：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/index")
    __View__() function index(context)
        if tonumber(context.Request.QueryString.ver) == 1 then
            return "/view/index_v1.view"
        else
            return "/view/index.view"
        end
    end
end)
```

```html
<!-- /html/view/index.view -->
<html>
    <head>
        <title>Test web Current</title>
    </head>
    <body>
    </body>
</html>
```

```html
<!-- /html/view/index_v1.view -->
<html>
    <head>
        <title>Test web V1</title>
    </head>
    <body>
    </body>
</html>
```

访问`/index?ver=1`和`/index`可以看到不同的结果。通常`.view`是作为MVC中的View部分使用。稍后我们会来看它的详细使用规则。虽然框架限定了`.view`文件的渲染规则，但系统允许自定义渲染引擎实现其他规则。这点，在最后介绍。


### `System.Web.__Switch__`

实际开发中，我们也会遇到需要由前端确定数据取得格式的问题，通常是返回视图结果，或者返回Json数据，如果为此特意定义两个API接口，
而两个接口的逻辑完全一样，仅仅返回方式不同，并不利于维护。所以，系统还提供了一个`__Switch__`特性，它的使用方式和`__View__`一致。

不同点在于，它会根据请求中的Accept字段的要求来返回数据，如果请求`application/json`，那么无视掉视图模板，将数据以Json格式返回。
如果请求中接受`text/html`或者`text/plain`，那么以视图模板生成内容返回。

（测试需要配合前端代码，此处略）


### `System.Web.__File__`

如果需要动态生成文件，也可以使用`__File__`和`__Iterator__`组合的形式，`__File__`特性申明这个处理是用来输出文件内容，
`__Iterator__`这个特性确保函数以迭代器的形式运行，可以通过yield多次返回值的方式，将结果输出给客户端，我们可以将文件名
指定给`__File__("download.csv")`，但通常来说直接在函数中，将文件名第一个返回更加方便和直观。

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    local yield = coroutine.yield

    __Route__("/download")
    __File__() __Iterator__()
    function download(context)
        yield("download.txt") -- 返回文件名

        -- 输出文件内容
        for i = 1, 10 do
            yield("This is line " .. i)
            yield("\n")
        end
    end
end)
```



### Application的定义

下面是`System.Web.Application`类申明的资源:

静态属性             |类型                                |描述
:-------------------|:-----------------------------------|:---------------
ConfigSection       |System.Configuration.ConfigSection  |只读，提供了Web App的配置定义，详见[配置系统](014.configuration.md)


属性                 |类型                       |描述
:-------------------|:--------------------------|:---------------
_Application        |System.Web.Application     |获取根Web app，因为继承自`System.Module`，所以，可以实现树状的代码管理，这就需要能定位根Web App，所以路由，控制器等资源都仅注册在根Web App
_Config             |Table                      |设置配置，使用上面定义的`ConfigSection`配置定义来解析，稍后介绍
_Root               |String                     |读写Web App访问Url的根路径，通常是空，Web App就可以匹配所有请求的Url，如果设置为`/test`，那么仅能匹配`/test/*`的url，也就是作为子网站使用
_ErrorHandler       |Function                   |错误处理函数，请求时代码执行发生的错误，会被传入这个函数，通常可以考虑直接输出到客户端（便于Debug）或者是错误日志


函数                |参数                        |返回                      |描述
:-------------------|:--------------------------|:-------------------------|:--------------------
Url2Path            |url                        |path                      |将Url请求地址转为对应该Web App的地址（即移除子网站根路径）
Path2Url            |path                       |url                       |将Web App的指定地址转为Url请求地址（即拼接子网站根路径）

这两个方法通常由系统内部使用，但`Path2Url`可能需要被用到视图中，转换特定的地址，稍后的例子中可以看到。


#### Web App作为子网站

在`/conf/init.lua`中我们使用`Web.Config`配置整个框架的行为，同样，我们可以对Web App进行配置，重点是配置`Root`，这样可以在一个nginx服务器上运行多个Web App，每个对应一个子网站:

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }
end)

import "PLBR"

require "plbr.route"

-- 配置文件在最后加载，这样可以在之前添加的新的配置定义（例如数据库连接，稍后演示）
require "plbr.config"
```

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        -- 子网站根路径
        Root            = "/sub",

        -- 默认导出给视图模板文件的函数
        -- 视图中可以直接使用export里面定义的函数
        View            = {
            Default     = {
                export   = {
                    Url = function (path) return _ENV:Path2Url(path) end,
                }
            }
        },
    }
end)
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/text")
    __Text__() function hello(context)
        return "hello world"
    end

    __Route__("/redirect")
    __Redirect__() function redirect(context)
        return "/text"
    end

    __Route__("/index")
    __View__[[/view/index.view]]
    function index() end
end)
```

```html
<!-- /html/view/index.view -->
<html>
    <head>
        <title>Test web</title>
    </head>
    <body>
        <a href="@Url('/text')">test url</a>
    </body>
</html>
```

重启服务器后，可以访问 `GET /sub/text`和`GET /sub/redirect`获取结果，可以看到这个Web App运行在`/sub`子网站中了。可以看到，我们的路由和重定向都无需处理`/sub`这部分地址。这样，通过调整`config.lua`文件，我们可以随意的调整子网站路径，不会影响Web App的执行。

访问`Get /sub/index`可以看到结果如

```html
<!-- /html/view/index.view -->
<html>
    <head>
        <title>Test web</title>
    </head>
    <body>
        <a href="/sub/text">test url</a>
    </body>
</html>
```

可见子网站的路径也会正常拼接上去，注意给定的地址必须是`/`开始，也就是绝对路径，处理会忽略相对路径。因为系统并没有办法判定哪些是url地址，哪些url地址需要附着子网站根路径，所以，这个操作需要自行完成，关于配置中`View`的使用，将在后面详细介绍。这里了解`export`的用法即可。

因此，我们可以定义多个Web App，然后对应到不同的`Root`地址，这就实现了一个nginx服务器多个Web App的运行。这点本文档就不具体给出例子，参照之前的例子即可。


#### Web App的错误处理

除了`Root`，Web App还可以配置一个`ErrorHandler`(对应`_ErrorHandler`属性)，用于绑定错误处理。通常我们会考虑将错误输出到客户端（开发期）或者日志中（运营期），不过在[Openresty][]中，Lua错误会自动记录到日志，仅需要用`error`抛出即可，所以，我们的例子是输出到客户端的形式:

``` lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        ErrorHandler = function(err, stack, context)
            context.Response.Write(err)
            context.Response:Close()
        end,
    }
end)
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/index")
    __View__[[/view/index.view]]
    function index(context) end
end)
```

```html
<!-- /html/view/index.view -->
<html>
    <head>
        <title>Test web</title>
    </head>
    <body>
        <p>@self.Data.NoExist</p>
    </body>
</html>
```

然后访问`GET /index`，会得到错误: `/root/www/html/view/index.view:7: attempt to index field 'Data' (a nil value)`，可见哪怕是视图，错误也可以被正确定位到。当然，实际使用的错误处理会相对复杂些，比如有专门的错误处理页面。

它的参数形式是为了符合`error`，第一个是错误信息，第二个是调用堆栈级别，第三个是上下文对象，这个会被`error`忽略，但我们其他的情况可以使用。


## Web 常量

下面是`System.Web`下面定义的枚举类型：

```lua
-- HTTP方法
__Flags__() __Sealed__() __Default__"GET"
enum "HttpMethod" {
    ALL                 = 0,
    "OPTIONS",
    "GET",
    "HEAD",
    "POST",
    "PUT",
    "DELETE",
    "TRACE",
    "CONNECT",
}

--- HTTP处理结果
__Sealed__() __Default__ "OK"
enum "HTTP_STATUS" {
    CONTINUE            = 100,  --请求可以继续。
    SWITCH_PROTOCOLS    = 101,  --服务器在升级头中交换了协议。
    OK                  = 200,  --请求成功完成。
    CREATED             = 201,  --请求已完成并导致创建新资源。
    ACCEPTED            = 202,  --已接受请求进行处理，但处理尚未完成。
    PARTIAL             = 203,  --实体报头中返回的元信息不是来自始发服务器的可确定集合。
    NO_CONTENT          = 204,  --服务器已完成请求，但没有新信息要发送回。
    RESET_CONTENT       = 205,  --请求已完成，客户端程序应重置导致发送请求的文档视图，以允许用户轻松启动另一个输入操作。
    PARTIAL_CONTENT     = 206,  --服务器完成了对资源的部分获取请求。
    WEBDAV_MULTI_STATUS = 207,  --这表示单个响应有多个状态代码。响应体包含描述状态代码的可扩展标记语言（XML）。有关详细信息，请参见http扩展以进行分布式创作。
    AMBIGUOUS           = 300,  --请求的资源在一个或多个位置可用。
    MOVED               = 301,  --已将请求的资源分配给新的永久统一资源标识符（uri），以后对该资源的任何引用都应使用返回的uri之一完成。
    REDIRECT            = 302,  --请求的资源暂时位于另一个uri下。
    REDIRECT_METHOD     = 303,  --对请求的响应可以在不同的uri下找到，应该使用该资源上的get http动词来检索。
    NOT_MODIFIED        = 304,  --请求的资源未被修改。
    USE_PROXY           = 305,  --必须通过位置字段提供的代理访问请求的资源。
    REDIRECT_KEEP_VERB  = 307,  --重定向请求保持相同的HTTP动词http/1.1行为。
    BAD_REQUEST         = 400,  --由于无效语法，服务器无法处理该请求。
    DENIED              = 401,  --请求的资源需要用户身份验证。
    PAYMENT_REQ         = 402,  --未在http协议中实现。
    FORBIDDEN           = 403,  --服务器理解请求，但无法完成它。
    NOT_FOUND           = 404,  --服务器未找到与请求的URI匹配的任何内容。
    BAD_METHOD          = 405,  --不允许使用http动词。
    NONE_ACCEPTABLE     = 406,  --未找到客户可接受的响应。
    PROXY_AUTH_REQ      = 407,  --需要代理身份验证。
    REQUEST_TIMEOUT     = 408,  --服务器等待请求超时。
    CONFLICT            = 409,  --由于与资源的当前状态冲突，无法完成请求用户应重新提交更多信息。
    GONE                = 410,  --请求的资源在服务器上不再可用，并且不知道转发地址。
    LENGTH_REQUIRED     = 411,  --如果没有定义的内容长度，服务器无法接受请求。
    PRECOND_FAILED      = 412,  --在服务器上测试时，一个或多个请求头字段中给定的前置条件计算为false。
    REQUEST_TOO_LARGE   = 413,  --服务器无法处理该请求，因为请求实体大于服务器能够处理的范围。
    URI_TOO_LONG        = 414,  --服务器无法为请求提供服务，因为请求uri的长度超过了服务器可以解释的长度。
    UNSUPPORTED_MEDIA   = 415,  --服务器无法为请求提供服务，因为请求实体的格式不受请求方法的请求资源支持。
    RETRY_WITH          = 449,  --执行相应操作后应重试请求。
    SERVER_ERROR        = 500,  --服务器遇到意外情况，无法满足请求。
    NOT_SUPPORTED       = 501,  --服务器不支持完成请求所需的功能。
    BAD_GATEWAY         = 502,  --服务器在充当网关或代理时，从试图完成请求时访问的上游服务器接收到无效响应。
    SERVICE_UNAVAIL     = 503,  --服务暂时过载。
    GATEWAY_TIMEOUT     = 504,  --请求在等待网关时超时。
    VERSION_NOT_SUP     = 505,  --服务器不支持请求消息中使用的HTTP协议版本。
}
```

普通网站开发中，通常只需要在路由绑定时使用`HttpMethod`。


## 编码和解码

`System.Web`提供了4个常用的解码和编码方法：

方法               |参数                                                                  |描述
:------------------|:--------------------------------------------------------------------|:------------------------------
HtmlEncode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |将字符串编码，以便在浏览器中显示
HtmlDecode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |解码字符串
UrlEncode          |text:String                                                          |对Url进行编码
UrlDecode          |text:String                                                          |对Url进行解码


用例类似：

```lua
require "PLoop.System.Web"

PLoop(function(_ENV)
    -- 注意，System.Web也是公共命名空间，所以，可以直接调用这些方法
    local str = HtmlEncode("<test>")
    print(str)               -- &lt;test&gt;
    print(HtmlDecode(str))   -- <test>

    str       = UrlEncode("/test?x=123")
    print(str)               -- %2Ftest%3Fx%3D123
    print(UrlDecode(str))    -- /test?x=123
end)
```


## 上下文 - System.Web.HttpContext

在上面的例子中，所有流程处理函数都有一个context作为第一个参数，这个值是`System.Web.HttpContext`类的对象，也就是Http上下文对象。结合`nginx.conf`中的`content_by_lua`处理，每个Http请求都会构建一个Http上下文对象，然后调用它的`Process`方法启动处理流程。

每个Http上下文对象都会有绑定唯一一个Web App，它会检查注册在这个Web App的所有路由，匹配后，执行对应的流程，然后返回结果给客户端。所以，Http上下文管理了整个Http请求的过程，同时也是处理过程中，共享数据的保存位置，上下文对象的存在，可以有效的避免共享数据导致的系统线程冲突问题。

所以，我们会看到这个上下文对象存在于Web框架的每个角落。对于绑定给路由的流程处理函数来说，它们可以从上下文中读取Http请求提交的信息，也能通过上下文将结果输出给客户端。

`System.Web.HttpContext`实际是抽象的，上面我们自己定义上下文类是继承自`NgxLua.HttpContext`，它继承了`System.Web.HttpContext`提供了针对[Openresty][]的实现。

`System.Web.HttpContext`申明了上下文类的定义：

抽象属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Request                     |System.Web.HttpRequest            |提供所有Http请求的信息，需要针对特定平台实现
Response                    |System.Web.HttpResponse           |用于向客户端输出处理结果，需要针对特定平台实现
SessionType                 |- System.Web.HttpSession          |用于生成用户会话对象的类，有默认实现，可根据业务自行扩展

----------------------------

最终属性（无法被覆盖）        |类型                                         |描述
:---------------------------|:--------------------------------------------|:-------------------------
Application                 |System.Web.Application                       |上下文对象所属的Web App，它具有独立的路由，控制器和其他资源
ProcessPhase                |System.Web.IHttpContextHandler.ProcessPhase  |当前请求处理的阶段，稍后介绍
Session                     |System.Web.HttpSession                       |获取用户会话对象，可用于保存会话数据
IsInnerRequest              |Boolean                                      |该上下文是否用于处理内部请求，为了分离业务逻辑，我们可以考虑用内部请求url的形式替代直接的对象调用，那么就需要能确认是否是内部请求，比如内部请求不需要验证用户权限等等

----------------------------

方法                        |参数                                                         |返回                        |描述
:---------------------------|:-----------------------------------------------------------|:---------------------------|:--------------------------------
Process                     |                                                            |无                          |启动请求处理的流程，这用于`content_by_lua`是本Web框架Http请求的入口
ProcessInnerRequest         |url: String, params: Table/nil, HttpMethod/nil              |status: HTTP_STATUS, result |启动一个内部请求，需要指定url，请求表单和Http方法

`ProcessInnerRequest`用于发起一个内部请求，内部请求的结果将返回两个值，第一个是处理的Http状态，另一个结果通常是使用`__Json__`输出的JSON数据，但因为是内部请求，输出数据不会被序列化，而是直接返回，这有助于返回数据库处理的结果集。避免过度序列化和反序列化操作。



### 请求 - System.Web.HttpRequest

`System.Web.HttpRequest`申明了包含所有Http请求信息的对象，实现可以参考[NgxLua][]的`NgxLua.HttpRequest`。

这个类申明了下面的属性：

抽象属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
ContentLength               |Number                            |请求的内容长度
ContentType                 |String                            |请求的MIME类型
Cookies                     |Table                             |获取客户端请求的Cookie集合
Form                        |Table                             |获取客户端提交的表单(非GET操作)
HttpMethod                  |HttpMethod                        |获取Http请求方法
IsSecureConnection          |Boolean                           |请求是否使用了HTTPS
QueryString                 |Table                             |获取客户端提交的请求数据(GET /xx?v=1&b=2)
RawUrl                      |String                            |获取原始请求字符串
Root                        |String                            |获取请求对应的根目录，对我们的例子即`~/www/html`
Url                         |String                            |获取请求的url

其中Cookies，Form，QueryString都需要返回字典table包含提交的键值对。


最终属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |请求对象所属的上下文对象
Handled                     |Boolean                           |该请求是否已经被处理了，稍后解释


### 响应 - System.Web.HttpResponse

`System.Web.HttpResponse`类申明了输出结果给客户端的对象，实现可以参考[NgxLua][]的`NgxLua.HttpResponse`。

这个类申明了以下的属性和方法：

抽象属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
ContentType                 |String                            |读写输出的MIME类型，类似`__Text__`使用`text/plain`
RedirectLocation            |String                            |读写重定向的url
RequestRedirected           |Boolean                           |请求是否已经被重定向
Write                       |Function+System.Text.TextWriter   |读写输出结果的函数或对象
StatusCode                  |HTTP_STATUS                       |读写处理结果的状态
Cookies                     |System.Web.HttpCookies            |输出一组Cookie

响应对象的`Write`属性可能是，函数，也可以使用流输出对象，所以，它定义成属性，而不是方法。使用类似

```lua
context.ContentType = "text/plain"
context.Write("Hello world")
```


最终属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |响应对象所属的上下文对象


抽象方法                     |参数                              |描述
:---------------------------|:---------------------------------|:-------------------------
SendHeaders                 |                                  |发送响应头
Close                       |                                  |关闭响应，结束输出
------------------------------------------------------------------------------------------

这三个方法都没有额外参数，所需的参数都可以通过响应对象获取到，例如重定向的地址。


方法                        |参数                                                                      |描述
:---------------------------|:------------------------------------------------------------------------|:-------------------------
Redirect                    |url: String, code: HTTP_STATUS/HTTP_STATUS.REDIRECT, raw: Boolean/false  |重定向到指定的地址，注意第三个参数raw，因为Web App可能只对应一个子网站，那么实际地址需要拼接子网站的根路径，如果希望不拼接，第三个参数需要传入true


### Cookie管理 - System.Web.HttpCookie & System.Web.HttpCookies

请求对象的`Cookies`仅仅是保存客户端提交的键值对的哈希表，使用起来类似:

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function test(context)
    return {
        User = { Name = context.Request.Cookies["name"] }
    }
end
```

响应对象的Cookie相对比较复杂，它的`Cookies`属性虽然是抽象的，但是已经有了一个默认实现，读取它时，会自动创建一个`System.Web.HttpCookies`类的对象，这是一个集合类，它的元素是`System.Web.HttpCookie`类的对象。

`HttpCookie`对象不需要自己创建，可以直接使用指定cookie名作为`HttpCookies`对象的字段访问，一个自动被创建的`HttpCookie`对象将会被返回，我们可以为它设置值和超时等等:

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function writecookie(context)
    context.Response.Cookies["ID"].Value = "TestUser1234"
    return {}
end
```

下面是`HttpCookie`具有的属性:

属性                        |类型                                  |描述
:---------------------------|:------------------------------------|:-------------------------
Domain                      |String                               |获取或设置要与cookie关联的域
Expires                     |Date                                 |获取或设置cookie的到期日期和时间。
MaxAge                      |Number                               |获取或设置cookie的最大使用期限。
HasKeys                     |Boolean                              |获取一个值，该值指示cookie是否具有子键。
HttpOnly                    |Boolean                              |获取或设置一个值，该值指定客户端脚本是否可以访问cookie。
SameSite                    |System.Web.HttpCookie.SameSiteValue  |获取或设置是否应将cookie限制为第一方或同一站点上下文
Name                        |String                               |获取或设置cookie的名称。
Path                        |String                               |获取或设置要用当前cookie传输的虚拟路径。
Secure                      |Boolean                              |获取或设置一个值，该值指示是否使用安全套接字层（SSL）传输cookie，即仅通过https。
Value                       |String                               |获取或设置单个cookie值。
Values                      |Table                                |获取包含在单个cookie对象中的键/值对的集合。

其中SameSiteValue的定义是

```lua

__Sealed__() enum "SameSiteValue" {
    Strict = "Strict",  -- 禁止第三方Cookie，跨站点时，该Cookie不会被发送
    Lax    = "Lax",     -- 禁止第三方Cookie，跨站点时，一般该Cookie不会被发送，但GET请求时可以例外
}
```

我们可以用`Date`类型为到期时间赋值：

```lua
context.Response.Cookies["ID"].Expires = System.Date.Now:AddDays(30)
```

也可以为Cookie添加子项：

```lua
context.Response.Cookies["ID"].Values["Age"] = 33
context.Response.Cookies["ID"].Values["Gender"] = "male"
```

`Cookies`属性是延迟加载的，仅当使用时通过默认值构造工厂创建，这点对其他对象属性也是一样的，可以有效的降低消耗。


### 用户会话 - System.Web.HttpSession

Http本身的机制下，每次的请求都是独立的，为了能跟踪特定的客户端和用户，我们通常需要采用多种方式来确定，但不管客户端采用何种方式，服务器端一般都采用用户会话的方式。

一般通过上下文对象的`Session`属性获取用户会话对象，对于特定的客户端，用户会话对象会有唯一的ID用于标识。默认用户会话对象是`System.Web.HttpSession`类的对象，但可以继承定制自己的会话类，然后作为Web App的特定上下文类的`SessionType`即可。

下面是会话对象的属性申明：

最终属性                     |类型                              |描述
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |用户会话所属的上下文对象
Items                       |                                  |一个索引器属性，用于读写键值对，虽然并没有限定，但最好键采用字符串，值采用可序列化的值，便于使用任意的存储方式
SessionID                   |String                            |获取用户会话的唯一ID
Timeout                     |Date                              |读写超时时间
TimeoutChanged              |Boolean                           |超时时间是否修改过
Canceled                    |Boolean                           |该用户会话是否取消，下次用户访问时，会使用新的ID
IsNewSession                |Boolean                           |该用户会话是否是新生成的会话，或者超时时间被修改，此时，需要将新会话ID输出到客户端（通常是通过Cookie)
ItemsChanged                |Boolean                           |会话保存的键值对是否有修改，如果有修改，需要将这些修改保存到会话数据存储位置
RawItems                    |Table                             |实际存储键值对的table，除非特殊需求，请不要直接使用它，即便使用，也请仅用于读取
IsTemporary                 |Boolean                           |是否是临时会话，通常保存会话用的Cookie将在用户关闭浏览器后清掉


上述属性中，通常业务部分只使用`Items`，其他属性由框架管理：

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function test(context)
    context.Session.Items.user = "TestUser1234"
    return {}
end
```

注意，`Items`无法跟踪多级修改，例如

```lua
context.Session.Items.UserList[1003] = { name = "king" }
```

通常这种情况，需要替换`UserList`：

```lua
local userList = System.Toolset.clone(context.Session.Items.UserList) or {}
userList[1003] = { name = "king" }
context.Session.Items.UserList = userList
```

`Session`的使用相对比较简单，只需要通过`Items`读写会话变量即可。而底层的问题在于，用何种方式将会话的唯一ID和超时等信息保存到客户端，以及如何保存用户会话变量。

通常这两个部分是通过两个作为管理器的对象完成处理，系统申明了两个接口分别对应这两部分处理。


#### System.Web.ISessionIDManager

`ISessionIDManager`申明了对会话ID的管理功能，包含新建，读取，保存，验证几个部分。

它声明了以下的抽象方法：

抽象方法                     |参数                                       |描述
:---------------------------|:------------------------------------------|:-------------------------
GetSessionID                |context: HttpContext                       |从上下文对象中读取会话的唯一ID
CreateSessionID             |context: HttpContext                       |为上下文对象新建一个唯一ID
RemoveSessionID             |context: HttpContext                       |删除该上下文对象的当前会话ID
SaveSessionID               |context: HttpContext, session: HttpSession |为上下文对象保存会话，即保存会话的唯一ID到客户端
ValidateSessionID           |id: String                                 |验证会话ID

通常我们会将会话ID以Cookie的形式保存在客户端中，这是比较简单也推荐的方式。我们来看它的两个实现：


##### System.Web.GuidSessionIDManager

这个实现使用`System.Guid`结构体的值作为会话ID，并且将它保存到指定的Cookie中，配合超时设定来管理会话ID的生存时间。

那么，我们可以调整之前的代码文件:

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/session")
    __Text__() function init(context)
        return context.Session.SessionID
    end
end)
```

多次访问`GET /session`可以看到会话ID唯一。请注意，申明这些管理器时，都需要传入当前的Web App进行绑定。


##### NgxLua.JWTSessionIDManager

这个会话ID管理器的设计基于[Json Web Token](https://jwt.io/)，它依赖于[resty.jwt](https://github.com/SkyLothar/lua-resty-jwt)，可以使用如下命令安装依赖

```shell
cd /usr/local/openresty/lualib/resty
wget https://raw.githubusercontent.com/jkeys089/lua-resty-hmac/master/lib/resty/hmac.lua
wget https://raw.githubusercontent.com/SkyLothar/lua-resty-jwt/master/lib/resty/jwt.lua
wget https://raw.githubusercontent.com/SkyLothar/lua-resty-jwt/master/lib/resty/jwt-validators.lua
wget https://raw.githubusercontent.com/SkyLothar/lua-resty-jwt/master/lib/resty/evp.lua
```

也可以自行安装。安装后，将上面例子中的init文件修改为

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    NgxLua.JWTSessionIDManager{ CookieName = "PLBR_JWT", TimeoutMinutes = 1 * 24 * 60, SecretKey = System.Guid.New():gsub("-", ""), HashAlgorithm = "HS256", Application = _ENV }

    -- 会话存储管理器
    NgxLua.JWTSessionStorageProvider{ Application = _ENV }
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/session")
    __Text__() function init(context)
        context.Session.Items["User"] = "Ann"
        return "请查看Cookie"
    end
end)
```

JWT设计上，会话ID和会话变量都会加密后保存在Cookie中，所以，我们需要同时提供配套的会话变量存储管理器。定义JWT会话ID管理器时，除了常规的Cookie名，超时分钟数外，还需要指定密钥和哈希算法，通常不输出时，默认值，就是例子中我们提供给`SecretKey`和`HashAlgorithm`的值，所以，通常也不需要提供（每次重启服务器后，会话ID都会失效，如果固定SecretKey则不会失效）。

保存后，重启服务器，然后访问`Get /session`，再F12打开调试器，查看Cookie，可以找到类似

```JS
PLBR_JWT:  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VyIjoiQW5uIiwiX3RpbWVvdXQiOjE1NzI4ODEyNDd9._fqPPE_dL2lNV8SQUSI2OlnxdJBtedt1xzUrULwAJQg
```

注意，JWT的机制比较特别，需要写入会话变量后（通常是用户标识），才会被保存到客户端。这个机制有个好处在于，会话变量保存在客户端，服务器端不需要保存任何会话数据，那么多服务器处理请求时，就不需要考虑如何共享会话数据这个问题。


#### System.Web.ISessionStorageProvider

`ISessionStorageProvider`接口申明了如何实现会话变量存储，它申明了以下的抽象方法：

抽象方法                     |参数                                       |描述
:---------------------------|:------------------------------------------|:-------------------------
Contains                    |id: String                                 |指定的会话ID是否有会话变量保存在存储中
GetItems                    |id: String                                 |返回指定会话ID的会话变量
RemoveItems                 |id: String                                 |清空指定会话ID的会话变量
SetItems                    |id: String, item: Table, timeout: Date/nil |更新指定会话ID的会话变量，可以指定超时
ResetItems                  |id: String, timeout: Date                  |更新指定会话ID的会话变量的超时
TrySetItems                 |id: String, item: Table, timeout: Date/nil |尝试将会话变量写入不存在于存储的会话ID，如果成功，返回true


系统提供了四种实现。


##### System.Web.TableSessionStorageProvider

这是直接用Lua的table作为存储，因为它不是线程安全的，仅用于普通测试。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
    TableSessionStorageProvider(_ENV)
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__("/session")
    __Text__() function init(context)
        context.Session.Items["ViewCount"] = (context.Session.Items["ViewCount"] or 0) + 1
        return "View Count: " .. context.Session.Items["ViewCount"]
    end
end)
```

访问`GET /session`可以看到View Count会被正确计数。


##### NgxLua.ShareSessionStorageProvider

这个存储是借用了[Openresty][]的共享字典，它是线程安全的，但限于容量，并不适合大规模使用，仅应用于小型网站，请注意`plbr_session_storage`是在`nginx.conf`文件中申明的。


```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
    ShareSessionStorageProvider("plbr_session_storage", _ENV)
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

访问`GET /session`可以看到View Count会被正确计数。



##### NgxLua.RedisSessionStorageProvider

这个存储依赖于[resty.redis](https://github.com/openresty/lua-resty-redis)，通常[Openresty][]随附安装，但如果加载失败，请自行安装。它使用Redis服务器保存会话变量。

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    GuidSessionIDManager { CookieName = "PLBR_SessionID", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }
    NgxLua.RedisSessionStorageProvider({ host = "127.0.0.1", port = 6379 }, _ENV)
end)

import "PLBR"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

访问`GET /session`可以看到View Count会被正确计数。这个适合中型网站，但用户规模很大时，对服务器始终是一定的负担。


##### NgxLua.JWTSessionStorageProvider

这个存储是配合`JWTSessionIDManager`使用，将会话变量存储在客户端中，可以很大的减轻服务器负担，而且加密的保存方式，也可以杜绝客户端任意修改它们。

但因为保存的变量是可以被解读的，所以，不能用于保存敏感信息。


## 页面渲染

视图模板文件用于渲染输出的网页，实际不仅仅是网页，也可以输出js，css等各种文本。系统通过模板文件的后缀名，决定使用哪个资源加载器，而视图模板文件的资源加载器，会使用渲染引擎对象来加载模板文键为渲染类，通常资源加载器会指定默认的引擎，但页面本身可以指定其他渲染引擎覆盖默认配置，不过这通常并不推荐。

**PLoop**目前仅提供两种渲染引擎: `System.Web.IRenderEngine`的匿名类作为静态文件渲染引擎，也就是将内容直接输出，另一个是扩展了它的`System.Web.PageRenderEngine`渲染引擎，在之前介绍的`.view`文件就是使用它来加载。

**PLoop**注册了多个视图模板文件类型，对应不同的扩展名，但它们都使用`System.Web.PageRenderEngine`生成视图渲染类，所以都遵循一致的规则。


### 路由和资源文件

在上面的处理中，我们使用了`__Text__`，`__Json__`，`__View__`绑定路由处理，但实际上，申明路由时，并不需要指定这些，重写route.lua为

```lua
-- /plbr/route.lua
__Route__ "/.*.lsp"
function LuaServerPage(request)
    return request.Url
end
```

这也是一个动态路由，用于匹配特定后缀名的url地址，例如`GET /view/index.lsp`，系统不会将后缀名开始的`.`用于模式匹配。

注意，它没有绑定 `__View__`特性，所以，函数并不是作为请求流程处理，它接受的参数的是`HttpRequest`的对象，而不是上下文对象，因为它并不直接完成业务逻辑，也不需要`HttpResponse`响应对象进行输出。

这个函数返回了文件地址(也就是`/view/index.lsp`)，那么系统会以资源文件的形式加载它，它也是动态加载的，修改可以实时反应。

我们将使用`.lsp`文件介绍默认渲染引擎的渲染规则，之后MVC中使用的`.view`模板也使用同样的规则。


### Lua Server Page (.lsp)

`.lsp`是较早设计的模版文件类型，通常我们会选择MVC框架，但这个模板使用起来相对简单。

新建我们的模板文件：

```html
<!-- /html/view/index.lsp -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>PLoop.System.Web Test Page</title>
        <script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
    </head>
    <body>
        <p>
            This is the first PLoop.System.Web test page.
        </p>
    </body>
</html>
```

重启服务器后，我们可以`GET /view/index.lsp`访问到结果，实际这个就是纯HTML，直接输出了。`PageRenderEngine`将模板文件会加载为页面渲染类，这个类将用于渲染出结果网页。


### Master Page (.master)

`PageRenderEngine`并不会检查HTML标签，而是按照特定规则嵌入自己的逻辑，首先，是母模板页面的定义规则。

通常同一个网站的内容有大量的复用，例如导航条，用户登录，广告位置，整体网页骨架等等。这些复用通常也是树状的形式。而对应树状最佳的就是类的继承系统。

`.master`后缀会生成抽象的页面渲染类，仅用于被继承，我们可以构造一个新的母模板页面：

```html
<!-- /html/share/global.master -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>@{title My web site}</title>
        @{jspart <!-- javascript placeholder -->}
    </head>
    <body>
        @{body}
    </body>
</html>
```

`PageRenderEngine`嵌入的规则都是以`@`开始的指令。其中类似`@{title My Web site}`申明了一个需要被继承实现的`Web Part`，`title`是这个部件的名字，剩余的`My Web site`是默认值。如果子类不实现，就使用默认值进行输出。

上面的`global.master`中定义了三个Web部件。现在我们可以在`/html/view/index.lsp`中实现这几个部件，限于规则，`<!-- /html/view/index.lsp -->`不再写入。

**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@title{
    测试页面
}

@body{
    <p>
        这是继承自母模版的子页面
    </p>
}
```

初次指定母模版页需要重启服务器，不然原页面的渲染方法会覆盖母模版的渲染方法，导致无法看到效果。

这个文件的第一行比较特殊，并非由渲染引擎去加载，在将文件交给渲染引擎前，系统会检查文件的第一行，是否存有一个Lua的table定义，如果存在，这行将被抽取出来作为加载文件时的配置文件使用。

至于开头是使用`@`还是对应JS文件的`//`都没有关系。对于视图模板文件，用`@`会比较统一。

这个配置中，当指定了`master`时，指定路径将作为母模板文件生成渲染类后被本模板文件继承。注意上面使用的是绝对路径，所以实际路径是`~/www/html/share/global.master`，如果使用相对路径，类似`global.master`对应路径为`~/www/html/view/global.master`，即以模板文件所在目录开始拼接相对路径。

为了实现一个Web部件，我们需要在两行的开头使用`@name{`和`}`，然后在这两行之间填入输出内容，这些输出内容需要带有缩进，推荐使用一个tab作为缩进。如前所述，这个默认渲染引擎并不会检查HTML标签等，因此如果不通过检查缩进，很难确认一个Web部件的开始和结束，为了简单起见，这里采用了依赖缩进判断定义范围的规则。

实际而言，Web部件的实现会生成为渲染类的一个方法，名字类似`Render_name`，参数以及实际渲染逻辑由渲染引擎生成。而母模版的没有申明Web部件，所以，它的所有内容会生成在`Render`方法中，所谓页面渲染，就是构建页面渲染类的对象，然后启动它的`Render`方法（继承自母模板），而Render方法会调用各个Web部件的渲染方法，以此达成整个页面的渲染工作。

所以，通常将定义Web部件视为定义方法即可。

上面的例子，输出结果是

```html
<!-- /html/share/global.master -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <!-- javascript placeholder -->
    </head>
    <body>
        <p>
            这是继承自母模版的子页面
        </p>
    </body>
</html>
```

注意，渲染引擎会积累缩进处理，确保以易读的形式输出内容，不过后面会看到如何去掉所有缩进和换行来减少输出内容的长度。


### 超类Web部件

`.master`文件可以指定其他`.master`为母模版，甚至`.lsp`文件也可以指定其他的`.lsp`文件为母模版。母模板实际没有限定，`.master`仅仅在于它生成的是抽象类，不适合直接输出结果罢了。

模板和母模板的关系，就是最后生成的渲染类之间的继承关系。

当覆盖了母模版的Web部件定义后，如果需要输出母模版的Web部件，可以使用`@{super:name}`的形式：

**/view/index2.lsp**

```html
@{ master = "index.lsp" }

@body{
    @{super:body}
    <p>
        This is the a PLoop.System.Web test page.
    </p>
}
```

这里使用`index.lsp`作为母模板，并覆盖了`body`部件，通过`@{super:body}`可以输出`index.lsp`设置的内容，并且决定了输出的位置。访问`GET /view/index2.lsp`可以查看结果。


### 混合Lua代码

为了将Lua业务逻辑嵌入HTML内容中进行输出，`PageRenderEngine`提供了四种方式：

#### Block

用于定义纯Lua的局部函数，渲染类方法等，可以认为是渲染类定义时的纯Lua部分，一般在模板文件的最开始定义，这样定义的局部函数可以被整个文件使用:


**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@{
    local function rollDice(num, max, add)
        local sum = add

        for i = 1, num do
            sum = sum + math.random(max)
        end

        return sum
    end
}

@title{
    测试页面
}

@body{
    <p>
        丢骰子 6d8 + 3: @rollDice(6, 8, 3)
    </p>
}
```

块定义由`@{`和`}`包裹，里面必须是纯Lua代码。在上面例子中定义了局部函数`rollDice`，稍后在Body部件中使用了这个函数。

除了在最开始使用块定义外，也可以在Web部件等渲染方法(含下面介绍的混合方法)内使用，如果连续使用多行Lua代码时，较为方便：

**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@title{
    测试页面
}

@body{
    <p>
        @ {
            local hour, msg = tonumber(os.date():match("(%d+):"))
            if hour < 10 then
                msg = "Good morning"
            elseif hour > 20 then
                msg = "Good night"
            else
                msg = "Have a nice day"
            end
        }
        @msg
    </p>
}
```

这种用法，请特别注意保持好缩进。否则系统无法判定结束位置。


#### Inline

内联Lua用于打印结果，通常使用`@`开始，然后跟一个Lua表达式，上例使用的`@rollDice(6, 8, 3)`就是内联用法。这个表达式的结果会被直接输出。

通常引擎可以识别函数调用，也可以识别复杂的类似`self.Items:Map("x=>x.id"):Join(",")`这样复杂的表达式，但类似`a + b`这样的就无法确认后面的`+ b`是文字还是表达式的一部分，这时候，必须用括号括起来类似`@(a+b)`。

如果输出的文本需要做转码，可以使用`@\`作为开始：

**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@title{
    测试页面
}

@body{
    <p>
        转码测试 : @\"<test/>"
    </p>
}
```

输出结果为

```html
<!-- /html/share/global.master -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <!-- javascript placeholder -->
    </head>
    <body>
        <p>
            转码测试 : &lt;test/&gt;
        </p>
    </body>
</html>
```

内联也支持使用字符串定义作为表达式，但不管怎样，使用括号都可以明确的划定表达式。

表达式的结果会被序列化输出，这点对于JS会比较方便：

**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@title{
    测试页面
}

@jspart{
    <script type="text/javascript">
        var data = @List(10):Map("x=>x^2"):ToList();
    </script>
}

@body{
    <p>
        转码测试 : @\"<test/>"
    </p>
}
```

输出结果为

```html
<!-- /html/share/global.master -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <script type="text/javascript">
            var data = [1,4,9,16,25,36,49,64,81,100];
        </script>
    </head>
    <body>
        <p>
            转码测试 : &lt;test/&gt;
        </p>
    </body>
</html>
```


#### Full-line

为了控制输出，我们还需要能使用Lua的控制语句，类似`if`, `for`等，这时候就需要使用全行代码的机制。也就是将一整行作为Lua代码使用。

通常使用`@>`指示该行是全行代码段。但如果跟着的是Lua的关键字，就可以省略为`@`指示：

**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@title{
    测试页面
}

@body{
    @ local a, b = math.random(100), math.random(100)
    <p>@a + @b = @(a+b)</p>
    <p>
    @ local hour = Date.Now.Hour
    @ if hour < 11 then
        Good morning
    @ elseif hour > 20 then
        Good night
    @ end
    </p>
}
```

如前所述，Body部件实际会转换为类方法，而全行代码段自然就是方法内的结构控制语句。通过代码块，内联，全行代码三种方式，我们可以很容易的混合Lua代码和HTML输出内容。


#### Mixed Method

Web部件仅仅是用于填充母模板申明的位置，既然它们实际是类方法，那么通过参数控制输出是很自然的操作。我们需要提供能附带参数的形式，这个就是混合方法：

**/html/view/index.lsp**

```HTML
@{ master = "/share/global.master" }

@{
    local function appendVerSfx(path, version, suffix)
        return path .. suffix .. (version and "?v=" .. tostring(version) or "")
    end
}

@javascript(name, version) {
    <script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@title{
    测试页面
}

@jspart{
    @{ javascript("jquery-2.1.4.min") }
    @{ javascript("index", 3) }
}

@body{
    <p>混合方法应用</p>
}
```

输出结果为:

```HTML
<!-- /html/share/global.master -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
        <script type="text/javascript" src="/js/index.js?v=3"></script>
    </head>
    <body>
        <p>混合方法应用</p>
    </body>
</html>
```

这里我们定义的`javascript`就是一个混合方法，使用时和Web部件的使用一致，只是多了参数传入。


### Helper Page (.helper)

Web部件通常作为网页的骨架（占位）存在，混合方法相对来说，基本是为了复用和不用在多处使用和维护同一组功能。所以，混合方法通常是用于作为帮助函数，它们通常是功能性质的，如果走渲染类的继承机制，并不足够自由，为了充分利用，框架提供了`.helper`模板文件，它用于存储这些混合方法。

`.helper`文件生成的是接口(interface)，这样它可以被任何的页面模板文件使用。扩展它的页面模板文件中，可以直接使用这些混合方法。

一些比较共通的`.helper`，可以使用母模版页扩展它们，这样，由母模版页派生的各个视图文件，就可以直接使用，而不需要自己管理。

我们新建一个helper文件，并修改`global.master`：

**/html/share/global.helper**

```html
@{
    local function appendVerSfx(path, version, suffix)
        return path .. suffix .. (version and "?v=" .. tostring(version) or "")
    end
}

@javascript(name, version) {
    <script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

**/html/share/global.master**

```html
@{ helper = "global.helper" }

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>@{title My web site}</title>
        @{jspart <!-- javascript placeholder -->}
    </head>
    <body>
        @{body}
    </body>
</html>
```

上面在配置table中使用`helper`指定帮助文件，多个文件可以用`,`号分割，因为我们可以扩展任意多个接口。

那么对应到`index.lsp`文件：

**/html/view/index.lsp**:

So the *index.lsp* :

```html
@{ master = "/share/global.master" }

@jspart{
    @{ javascript("jquery-2.1.4.min") }
    @{ javascript("index", 3) }
}
```

为了避免以前定义的影响，可以重启下服务器，然后访问`GET /view/index.lsp`。结果为

```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>My web site</title>
        <script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
        <script type="text/javascript" src="/js/index.js?v=3"></script>
    </head>
    <body>

    </body>
</html>
```


### Embed Page (.embed)

除了利用母模版系统的继承机制外，还可以使用嵌入文件路径的方式，将其他资源文件的输出嵌入到自身，这是使用`@[path default text]`的指示，通常我们使用`.embed`作为被嵌入文件的后缀名，但这个并不是限定，它和其他`.lsp`没有区别，只是通过后缀可以明确用法。

**/html/share/notice.embed**

```html
<h2>
    这是被嵌入的文本
</h2>
```

**/html/view/index.lsp**

```html
@{ master = "/share/global.master" }

@title{
    测试页面
}

@body{
    @[/share/notice.embed <!-- Notice placeholder -->]
}
```

访问`GET /view/index.lsp`结果为

```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <!-- javascript placeholder -->
    </head>
    <body>
        <h2>
            这是被嵌入的文本
        </h2>
    </body>
</html>
```

对于这里的路径和默认值，实际也可以使用内联代码的形式，另外，类似`.css`和`.js`文件也可以嵌入使用，首先我们修改帮助文件：

**/html/share/global.helper**

```html
@{
    local function appendVerSfx(path, version, suffix)
        return path .. suffix .. (version and "?v=" .. tostring(version) or "")
    end
}

@javascript(name, version) {
    <script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@rawjs(name, version, id) {
    <script type="text/javascript">
        @[/js/@appendVerSfx(name, nil, '.js') // /js/@appendVerSfx(name, version, '.js')]
    </script>
}
```

然后修改

**/html/view/index.lsp**

```html
@{ master = "/share/global.master" }

@title{
    测试页面
}

@jspart{
    @{ javascript("jquery-2.1.4.min") }
    @{ rawjs("index") }
}

@body{
    @[/share/notice.embed <!-- Notice placeholder -->]
}
```

先直接访问`GET /view/index.lsp`可以得到


```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
        <script type="text/javascript">
            // /js/index.js
        </script>
    </head>
    <body>
        <h2>
            这是被嵌入的文本
        </h2>
    </body>
</html>
```

这里输出的是默认值部分，可见指定的名字被输出了。那么我们新建一个js文件：

```js
//html/js/index.js
var test = 123;
```

再次访问`GET /view/index.lsp`可得

```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
        <script type="text/javascript">
            //html/js/index.js
            var test = 123;
        </script>
    </head>
    <body>
        <h2>
            这是被嵌入的文本
        </h2>
    </body>
</html>
```

css文件也可以这样嵌入，这么做的好处在于，修改js和css内容后，因为是嵌入网页输出，客户端不会因为缓存了js和css文件导致无法实时看到变更，等部署时，修改成文件链接即可。这点可以通过调整`global.helper`里面`rawjs`的实现完成。

css和js是静态文件，由静态渲染引擎加载进入，当然不用在意这个细节。


### Inner Request Page

嵌入页面实际常用在js和css文件上，很少用于嵌入其他视图模板文件，因为通常模板文件都会和一组业务逻辑挂钩，直接嵌入灵活性不足。

那么为了嵌入其他业务的输出，我们需要使用内部请求，请求到的结果直接嵌入输出到客户端，为此我们使用`@[~path (param, httpmethod)]`的指示。

注意，`path`和后面的参数部分需要用空格分开，因为`path`部分可以使用内联代码，可以认为是模板字符串，而后面的`(param, httpmethod)`是纯Lua的代码，所以它们之间需要空格间隔。

`param`是一个含有表单的table，可以为nil。`httpmethod`是使用的HTTP方法。

系统将以`path`为请求路径，完成一个内部请求处理，下面看个使用例子：

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__ "/.*.lsp"
    function LuaServerPage(request)
        return request.Url
    end

    __Route__ "/data" __Json__()
    function data(context)
        return { a = 1, b = 2, c = 3 }
    end
end)
```

**/html/view/index.lsp**

```html
@{ master = "/share/global.master" }

@title{
    测试页面
}

@jspart{
    <script type="text/javascript">
        var data = @[~/data]
    </script>
}

@body{
    @[/share/notice.embed <!-- Notice placeholder -->]
}
```

重启后，访问`GET /view/index.lsp`，结果是

```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>测试页面</title>
        <script type="text/javascript">
            var data = {"b":2,"a":1,"c":3}
        </script>
    </head>
    <body>
        <h2>
            这是被嵌入的文本
        </h2>
    </body>
</html>
```

可见这里的我们发起了内部请求，这种方式可以更好的复用服务器资源。


### Lua Code file (.lua)

通常`.lsp`文件中，渲染页面的部分并不是很适合处理业务逻辑，仅适合做一些简单的渲染判定。为了进行业务处理，可以为它申明`OnLoad`方法，这个方法会在渲染页面前被执行:

**/html/view/index.lsp**

```html
@{ master = "/share/global.master" }

@{
    function OnLoad(self, context)
        -- Generate a cookie
        context.Response.Cookies["TestCookie"].Value = "Test"
        context.Response.Cookies["TestCookie"].Expires = System.Date.Now:AddMinutes(10)
    end
}

@title{
    测试页面
}

@jspart{

}

@body{
    @[/share/notice.embed <!-- Notice placeholder -->]
}
```

这里的OnLoad处理了Cookie，它会接收到上下文对象方便处理。不过通常来说，当业务逻辑足够复杂时，将这部分分离到独立的代码文件，会更加适合：

```lua
-- /html/view/index.lua
class "Index" {}  -- 部分类申明，具体由视图模板文件完成

-- 定义OnLoad方法
function Index:OnLoad()
    self.PageTitle = "Test Page"

    self.Data = {
        { Name = "Ann", Age = 12 },
        { Name = "King", Age = 32 },
        { Name = "July", Age = 22 },
        { Name = "Sam", Age = 30 },
    }
end
```

代码文件中我们生成了具体的数据，并保存到对象中。

**/html/view/index.lsp**

```html
@{ master = "/share/global.master", code = "index.lua" }

@title{
    @self.PageTitle
}

@jspart{
    @{ javascript("jquery-2.1.4.min") }
}

@body{
    <table border="1">
        <thead>
            <tr>
                <th>Person Name</th>
                <th>Person Age</th>
            </tr>
        </thead>
        <tbody>
        @> for _, data in ipairs(self.Data) do
            <tr>
                <td style="background-color:cyan">@data.Name</td>
                <td>@data.Age</td>
            </tr>
        @> end
        </tbody>
    </table>
}
```

配置中可以使用`code`指明代码文件，通常一般在同目录，所以指定名字即可，通过相对路径访问会直接拿到。代码文件申明的类名必须和文件名一致（大小写无视）。这个类会在模板文件转换为渲染类时补完。

在之前也明确提到，Web部件实质是类方法，所以，这里用到的self就是渲染类的对象，在`OnLoad`中被赋予了数据。所以，我们可以使用这些数据生成结果：

```html

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Test Page</title>
        <script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
    </head>
    <body>
        <table border="1">
            <thead>
                <tr>
                    <th>Person Name</th>
                    <th>Person Age</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="background-color:cyan">Ann</td>
                    <td>12</td>
                </tr>
                <tr>
                    <td style="background-color:cyan">King</td>
                    <td>32</td>
                </tr>
                <tr>
                    <td style="background-color:cyan">July</td>
                    <td>22</td>
                </tr>
                <tr>
                    <td style="background-color:cyan">Sam</td>
                    <td>30</td>
                </tr>
            </tbody>
        </table>
    </body>
</html>
```

虽然`.lsp`可以比较简单的输出页面，但实际来说，灵活度不够，通常我们会使用MVC框架，这里关于`.lsp`的介绍都可以用于MVC框架中的`.view`视图模板文件。



## MVC框架 - System.Web.MVC

上面介绍了路由，页面渲染，以及请求上下文的各个对象，但它们的应用都相对简单，在复杂的网站架构时很难应对多变的需求。通常我们会使用基于MVC模式设计的架构（通常还会继续扩展，但基本会以MVC为基础）。


### 路由管理

MVC模式下，路由用于将请求转给控制器:

```lua
-- /plbr/route.lua
__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
function MVC(context, controller, action, id)
    controller = controller ~= "" and controller or "home"
    action     = action     ~= "" and action     or "index"
    id         = tonumber(id)

    return ("/controller/%scontroller.lua"):format(controller), { Action = action, ID = id }
end
```

为了特化处理，路由系统提供了正则以外的模式匹配机制，可以采用`{name?|pattern}/`的形式进行模式匹配：

* `{xxx}` 代表一个捕获
* `{xxx?}` 代表这个捕获可以匹配空字符串，如果为空，其后的`/`也会被忽略
* `{xxxx|pattern}` 提供了捕获用的模式字符串用于强制匹配

这些捕获将按照顺序传给路由的处理函数，路由处理函数负责拼接出控制器的路径，并将`Action`(必须)和其他信息作为控制器的初始化表传入，生成新的控制器对象来完成请求处理。

下面是请求地址和对应的控制器的例子：

请求URL               |控制器地址                       |初始化表
:--------------------|:--------------------------------|:--------------------
`/`                  |/controller/homecontroller.lua   |{ Action = "index" }
`/user/12`           |/controller/usercontroller.lua   |{ Action = "index", ID = 12 }
`/user/account/12`   |/controller/usercontroller.lua   |{ Action = account, ID = 12 }


### 控制器 - System.Web.Controller

控制器文件生成的控制器类主管着请求对应的业务逻辑，它属于资源文件，可以在开发模式下实时查看修改结果。

```lua
-- /html/controller/usercontroller.lua
class "UserController" (function(_ENV)
    inherit "Controller"

    local yield = coroutine.yield

    __Action__() __View__[[/view/user.view]]
    function index(self, context)
        return {
            Data = context.Session.RawItems  -- 特殊用，用session缓存用户数据
        }
    end

    __Action__("data", HttpMethod.POST)
    function setdata(self, context)
        context.Session.Items[context.Request.Form.key] = context.Request.Form.value

        self:Redirect("/user") -- 走index的动作
    end

    -- 下载test.csv文件，利用迭代器多次输出结果给客户端
    __Action__("download") __File__() __Iterator__()
    function download(self, context)
        yield("test.csv")  -- 因为__File__没有指定文件名，第一个输出值将作为文件名

        yield("col1, col2, col3\n")

        for i = 1, 10 do
            for j = 1, 3 do
                yield(i * 10 + j)
                yield(",")
            end
            yield("\n")
        end
    end
end)
```

然后定义视图

**/html/view/user.view**:

```html
@{ master = "/share/global.master" }

@body{
    <table border="1">
        <thead>
            <tr>
                <th>Key</th>
                <th>Value</th>
            </tr>
        </thead>
        <tbody>
        @for key, data in pairs(self.Data) do
            <tr>
                <td style="background-color:cyan">@\key</td>
                <td>@\data</td>
            </tr>
        @end
        </tbody>
    </table>
    <form action="/user/data" method="POST">
        <p>
            <span>键</span><input type="text" name="key" value=""/>
        </p>
        <p>
            <span>值</span><input type="text" name="value" value=""/>
        </p>
        <input type="submit" value="提交"/>
    </form>
}
```

重启服务器后，访问`GET /user`即可，之后可以输出新的键值对，点击提交后，会保存在会话变量中，提交后，客户端会被重定向到`/user`路径，这样就能直接利用`index`动作获得显示内容。

下面是一些细节：

* 控制器类名必须和文件名一致（大小写无视）

* 控制器类必须继承`System.Web.Controller`

* 控制器类的方法需要使用`__Action__`特性来绑定动作，绑定时可以指定动作名（默认即函数名）和HTTP方法，当响应动作发生时，检查HTTP方法找到指定动作的处理方法，这个方法将被用于处理请求

* 多个方法可以绑定同一个事件，只要它们不注册同样的HTTP方法

* 类似于在路由文件中使用`__View__`，我们可以同样对各个动作的处理方法指定`__Text__`, `__Json__`和`__View__`特性，来将输出结果以特定格式输出，注意，如果在返回结果前，方法发起了重定向操作，那么这些特性的处理会被忽略。

* 通常用`__View__`这些特性会限定了处理方法的输出格式，为了便利，控制器类提供了多个方法，用于指定输出:

方法                     |参数                        |描述
:------------------------|:--------------------------|:-------------------
Text                     |text/(iter, ...)           |将指定文本，或从迭代器获取的文本输出给客户端
View                     |path[, init]               |指定视图模板文件路径以及初始化表，由对应的视图渲染类完成输出
Json                     |object[, type]             |将目标序列化为JSON数据后，输出给客户端
AutoSwitch               |path, init                 |根据请求将初始数据填入模板或者转换为JSON数据返回客户端
File                     |[name], text/(iter, ...)   |以指定的名字，将文本或迭代器产生的文本以文件的形式输出给客户端，如果不指定文件名，迭代器返回的第一个字符串将作为文件名使用
Redirect                 |path[, raw]                |重定向
NotFound                 |                           |返回404，没有找到资源
Forbidden                |                           |返回403，禁止访问该资源
ServerError              |                           |返回500，服务器错误

不再重复使用这些特定和方法。视图规则和`.lsp`一致，所以也不在重复说明。重点是Model模块。同时，因为`__Switch__`等特性的存在，推荐
仅在函数中返回table数据，由这些特性决定输出结果，更为方便。


### 数据 - Model

通常我们会使用[抽象数据实体框架](0.19.data.md)组为Model部分。这块主要申明了数据实体类和数据库表结构之间的映射。这样，我们就可以在控制器的业务处理中便利的处理数据库数据。

作为例子，我们在PLoop数据库中创建一个用户表：

```sql
use PLoop;

CREATE TABLE IF NOT EXISTS `user`(`id` INT UNSIGNED AUTO_INCREMENT, `createdate` DATETIME NOT NULL, `name` VARCHAR(128), `telno` VARCHAR(128),  PRIMARY KEY (`id`), UNIQUE IDX_name(`name`), UNIQUE IDX_telno(`telno`))ENGINE=InnoDB;
```

那么，根据这个表，我们可以新建我们的Model文件(实际上，利用反射机制，可以根据Model定义来自动构建数据库，更为方便，不过目前仅提供了MySQL的基于Model自动构建数据库表的接口： MySQLConnection:DropAllTables()用于删除所有表，MySQLConnection:CreateNonExistTables(ns) 用于根据ns命名空间中的数据库实体类定义，
自动生成不存在的数据库表结构，不过这通常只适合用于开发期，暂时不提供更新表结构的API)

```lua
-- /plbr/database.lua
require "PLoop.System.Data"

Application "PLBR" (function(_ENV)
    -- 必须import这两个库，才能直接使用相关特性
    import "System.Data"
    import "System.Configuration"

    __DataContext__()
    class "UserDataContext" (function(_ENV)

        export { NgxLua.MySQL.MySQLConnection, UserDataContext }

        -----------------------------------------------------------
        --                     数据库连接配置                     --
        -----------------------------------------------------------
        __Static__() property "ConnectionOption" { type = NgxLua.MySQL.ConnectionOption }

        -----------------------------------------------------------
        --                       构造体方法                       --
        -----------------------------------------------------------
        function __ctor(self)
            -- 创建数据库连接
            self.Connection = MySQLConnection (UserDataContext.ConnectionOption)
        end

        -----------------------------------------------------------
        --                       数据实体类                       --
        -----------------------------------------------------------
        __DataTable__{
            name            = "user",    indexes = {
                { fields    = { "id" },  primary = true },
                { fields    = { "name" }, unique = true },
                { fields    = { "telno"}, unique = true },
            }
        }
        class "User" (function(_ENV)
            __DataField__{ autoincr = true }
            property "id"           { type = NaturalNumber }

            __DataField__{ notnull  = true }
            property "createdate"   { type = Date }

            __DataField__()
            property "name"         { type = String }

            __DataField__()
            property "telno"        { type = String }
        end)
    end)

    -----------------------------------------------------------
    --                   数据连接的配置定义                    --
    -----------------------------------------------------------
    __ConfigSection__(Application.ConfigSection.PLBR, "MySQL", NgxLua.MySQL.ConnectionOption)
    function applyMySqlSetting(field, value, app)
        UserDataContext.ConnectionOption = value
    end
end)
```

这个文件申明了`UserDataContext`数据库上下文类，里面定义了`User`数据实体类，也申明了数据库连接的配置定义。注意上面的配置定义申明在`Application.ConfigSection`上，所以实际同服务器的所有Web App都可以使用这个配置定义，但我们通过`PLBR`名可以区分开各个Web App。

这个配置在`config.lua`中设置：


```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        PLBR                    = {
            MySQL               = {
                host            = "127.0.0.1",
                port            = 3306,
                database        = "PLoop",
                user            = "admin",
                password        = "管理员密码",
                charset         = "utf8mb4",
                max_packet_size = 2 * 1024 * 1024,
            },
        },
        ErrorHandler = function(err, stack, context)
            context.Response.Write(err)
            context.Response:Close()
        end,
    }
end)
```


配置文件加载后，数据库连接就被指定给`UserDataContext`上下文类了。

之后是修改`init.lua`加载model文件：

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    NgxLua.JWTSessionIDManager{ CookieName = "PLBR_JWT", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }

    -- 会话存储管理器
    NgxLua.JWTSessionStorageProvider{ Application = _ENV }
end)

import "PLBR"

-- 加载数据模型文件
require "plbr.database"

-- 加载路由文件
require "plbr.route"

require "plbr.config"
```

下面是一个简单的注册示例：

**/html/controller/usercontroller.lua**

```lua
class "UserController" (function(_ENV)
    inherit "Controller"

    __Action__("index", HttpMethod.GET)
    function index(self, context)
        if context.Session.Items.userid then
            -- 已登录
            with(UserDataContext())(function(ctx)
                local user = ctx.Users:Query{ id = context.Session.Items.userid }:First()
                self:View("/view/user.view", { User = user })
            end)
        else
            -- 注册界面
            self:View("/view/register.view")
        end
    end

    __Action__("register", HttpMethod.POST)
    function register(self, context)
        local telno = context.Request.Form.telno
        local name  = context.Request.Form.name

        with(UserDataContext())(function(ctx)
            local user = ctx.Users:Query{ telno = telno }:First()
            if user then
                context.Session.Items.userid = user.id
                return self:Redirect("/user")
            end

            with(ctx.Transaction)(function(trans)
                user = ctx.Users:Add{ telno = telno, name = name, createdate = Date.Now }
                ctx:SaveChanges()

                context.Session.Items.userid = user.id
                return self:Redirect("/user")
            end)
        end)
    end

    __Action__("logout", HttpMethod.GET)
    function logout(self, context)
        context.Session.Items.userid = nil
        self:Redirect("/user")
    end
end)
```

那么，我们通过在用户会话中保存`userid`来识别用户。下面是视图文件:

**/html/view/user.view**

```html
@{ master = "/share/global.master" }

@body{
    <p>用户名: @self.User.name</p>
    <p>手机号: @self.User.telno</p>
    <p>创建日期: @self.User.createdate:ToString()</p>

    <a href="/user/logout">登出</a>
}
```

**/html/view/register.view**

```html
@{ master = "/share/global.master" }

@body{
    <form action="/user/register" method="POST">
        <p>
            <span>手机号</span>
            <input type="text" name="telno"/>
        </p>
        <p>
            <span>用户名</span>
            <input type="text" name="name"/>
        </p>
        <input type="submit" value="注册"/>
    </form>
}
```

之后重启服务器（添加了model文件），访问`GET /user`就可以尝试注册和登出操作了。也可以查看数据库，检查被注册的用户情况。

数据库更多的处理，例如自动缓存等，请阅读[抽象数据实体框架](0.19.data.md)获取更多信息。



## 表单验证

MVC框架中的控制器大幅度降低了路由的使用，需要功能只需要直接增加控制器即可。到此，已经可以开始完成基本的网站开发功能。下面是一些框架提供的增强功能。首先是表单校验功能。

通常HTTP请求都会附带请求字符串(GET)或者表单(非GET，例如POST, PUT)，为了避免用户的错误输入（无论是刻意还是无意），我们需要对表单包含的请求值进行验证，这是一个非常通用而且麻烦的操作，由开发者自行完成相当繁琐，而且很难维护。

为了解决这个问题，结合**PLoop**的结构体系统，Web框架提供了`System.Web.__Form__`特性用于完成表单验证，以上面的`usercontroller`的`register`动作为例：

```lua
-- 本地化用，目前暂时不支持多语言
-- 如果需要多语言，这里请指定为代表字符串的常量
-- 之后在显示位置替换为实际字符串
__Form__.RequireMessage = "%s不能为空"
__Form__.NumberMessage  = "%s必须是数字"

-- 定义自定义结构体，对应不同的输入，需要提供错误消息
-- 必须指定__base，特别是数字类型，必须至少指定为Number
-- 这样系统才能自动完成转换工作
struct "Telno" { __base = String,
    function (val)
        if #val ~= 11 or not val:match("^1%d+$") then return "%s不是有效的移动电话号码" end
    end
}

struct "UserName" { __base = String,
    function (val)
        if val:match("[%s%p]+") then return "%s不能含有特殊字符" end
        if #val > 24 then return "%s长度超过限制" end
    end
}

__Action__("register", HttpMethod.POST)
__Form__{
    telno = { type = Telno, require = true },
    name = { type = UserName, require = true },
}
function register(self, context, form, err)
    if err then
        return self:View("/view/register.view", { Form = form, Error = err })
    end

    with(UserDataContext())(function(ctx)
        local user = ctx.Users:Query{ telno = form.telno }:First()
        if user then
            context.Session.Items.userid = user.id
            return self:Redirect("/user")
        end

        with(ctx.Transaction)(function(trans)
            user = ctx.Users:Add{ telno = form.telno, name = form.name, createdate = Date.Now }
            ctx:SaveChanges()

            context.Session.Items.userid = user.id
            return self:Redirect("/user")
        end)
    end)
end
```

修改`register.view`对应错误处理：

**/html/view/register.view**

```html
@{ master = "/share/global.master" }

@body{
    <form action="/user/register" method="POST">
        <p>
            <span>手机号</span>
            <input type="text" name="telno" value="@(self.Form and self.Form.telno)"/>
            @if self.Error and self.Error.telno then
            <br><span style="color:red">@\self.Error.telno:format("手机号")</span>
            @end
        </p>
        <p>
            <span>用户名</span>
            <input type="text" name="name" value="@(self.Form and self.Form.name)"/>
            @if self.Error and self.Error.name then
            <br><span style="color:red">@\self.Error.name:format("用户名")</span>
            @end
        </p>
        <input type="submit" value="注册"/>
    </form>
}
```

保存后，重新注册，随意输出错误信息可以看到，例如，手机号输入 `1`，用户名输入 `test.123`，那么注册后返回页面是:


```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>My web site</title>
        <!-- javascript placeholder -->
    </head>
    <body>
        <form action="/user/register" method="POST">
            <p>
                <span>手机号</span>
                <input type="text" name="telno" value="1"/>
                <br><span style="color:red">手机号不是有效的移动电话号码</span>
            </p>
            <p>
                <span>用户名</span>
                <input type="text" name="name" value="test.123"/>
                <br><span style="color:red">用户名不能含有特殊字符</span>
            </p>
            <input type="submit" value="注册"/>
        </form>
    </body>
</html>
```

这样，我们既可以显示用户输入值，又可以展示给用户错误信息。下面是一些细节：

* `__Form__`后面的定义表，实质就是结构体定义，所以，上面的例子，实际是定义了一个匿名结构体:

    ```lua
    local formType = struct {
        telno = { type = Telno, require = true },
        name = { type = UserName, require = true },
    }
    ```

    所以，表单验证实际就是将请求的请求字符串或表单通过这个匿名结构体的验证，验证如果失败，失败消息会保存在err参数中

* 无论是否验证通过，表单或请求字符串都会被保存到form参数中，和err参数一起传入原函数。我们可以通过判定err参数是否存在，来确定表单验证是否通过

* 需要为`__Form__.RequireMessage`和`__Form__.NumberMessage`指定本地化字符串，当然也可以用代表字符串的常量代替

* 可以自定义结构体来增加验证方式，可以将这类自定义结构体单独保存到一个文件，方便管理和复用。自定义结构体必须直接或间接的以`String`或`Number`为基础结构体，这样系统在验证前，会将上传的值做出对应的转换

一般来说，我们只需要定义成员结构体，但实际上也支持复杂的形式：

```lua
__Form__ { -- 以成员结构体为元素的数组结构体
    person = struct {
        struct {
            name = String,
            age  = Number,
        }
    }
}
__Action__() __Json__()
function query(self, context, form, err)
    return { Form = form, Error = err }
end
```

这里说明，传入的表单需要含有一个person的键，它的值是一个数组，这个数组的每个元素都是table（成员结构体），含有`name`和`age`两个字段。它们实际匹配下面设计的表单

```js
var form = {
    "person[1].name": "Ann",
    "person[1].age": 21,
    "person[2].name": "Ben",
    "person[2].age": 23,

}

// 或者更方便的Bulk Form
var form = {
    person = [
        {
            "name": "Ann",
            "age" : 21,
        },
        {
            "name": "Ben",
            "age" : 23,
        }
    ]
}
```

这样，就可以以对象的方式设计表单了。这个的使用可以自行尝试，相对来说，使用较少。另外申明为数组的成员也可以接受单个值，系统会自动将单个值封装为数组，所以，使用`form`访问时，可以直接用数组操作值，而不需要顾虑单值和多值的问题。



## 用户认证

当执行实际处理前，我们也需要对用户权限进行认证，这包括两个方面，一个是用户是否已经登录，第二个是用户是否具有指定权限。我们可以使用`System.Web.__Login__`特性来完成这个处理，当然也可以自行实现。这个并非强制功能，和`__Form__`一样都只是框架附赠的增强。


### 登录验证

`__Login__`可以检查用户会话中是否存在特定的键，以此判定用户是否已经登录，如果未登录，将访问重定位到指定的登录页面，并且保留之前访问的路径，以便登录后，跳转回去。

为此，我们需要修改配置文件:

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        PLBR                    = {
            MySQL               = {
                host            = "127.0.0.1",
                port            = 3306,
                database        = "PLoop",
                user            = "admin",
                password        = "管理员密码",
                charset         = "utf8mb4",
                max_packet_size = 2 * 1024 * 1024,
            },
        },
        Validator               = {
            Login               = {
                Key             = "userid",
                LoginPage       = "/user/login",
                PathKey         = "path",
            }
        },
        ErrorHandler            = function(err, stack, context)
            context.Response.Write(err)
            context.Response:Close()
        end,
    }
end)
```

这里通过`Validator.Login`配置`__Login__`的设置，包括三个配置项:

* Key - 用户会话中的特定键，用于判定用户是否已经登录
* LoginPage - 登录页地址
* PathKey - 保存之前访问地址的键

上面的配置，如果检查会话中不存在`userid`，那么就重定向到`GET /user/login?path=之前访问的地址`。


我们可以调整下用户控制器:

```lua
-- /html/controller/usercontroller.lua
class "UserController" (function(_ENV)
    inherit "Controller"

    -----------------------------------------------------------
    --                     验证结构体定义                     --
    -----------------------------------------------------------
    __Form__.RequireMessage = "%s不能为空"
    __Form__.NumberMessage  = "%s必须是数字"

    struct "Telno" { __base = String,
        function (val)
            if #val ~= 11 or not val:match("^1%d+$") then return "%s不是有效的移动电话号码" end
        end
    }

    struct "UserName" { __base = String,
        function (val)
            if val:match("[%s%p]+") then return "%s不能含有特殊字符" end
            if #val > 24 then return "%s长度超过限制" end
        end
    }

    -----------------------------------------------------------
    --                     控制器动作定义                     --
    -----------------------------------------------------------
    __Login__()
    __Action__("index", HttpMethod.GET)
    function index(self, context)
        with(UserDataContext())(function(ctx)
            local user = ctx.Users:Query{ id = context.Session.Items.userid }:First()
            self:View("/view/user.view", { User = user })
        end)
    end

    __Action__("login", HttpMethod.GET)
    function login(self, context)
        self:View("/view/register.view")
    end

    __Action__("register", HttpMethod.POST)
    __Form__{
        telno = { type = Telno, require = true },
        name = { type = UserName, require = true },
    }
    function register(self, context, form, err)
        if err then
            return self:View("/view/register.view", { Form = form, Error = err })
        end

        with(UserDataContext())(function(ctx)
            local user = ctx.Users:Query{ telno = form.telno }:First()
            if user then
                context.Session.Items.userid = user.id
                return self:Redirect("/user")
            end

            with(ctx.Transaction)(function(trans)
                user = ctx.Users:Add{ telno    = form.telno, name = form.name, createdate = Date.Now }
                ctx:SaveChanges()

                context.Session.Items.userid = user.id
                return self:Redirect("/user")
            end)
        end)
    end

    __Action__("logout", HttpMethod.GET)
    function logout(self, context)
        context.Session.Canceled = true
        self:Redirect("/user")
    end
end)
```

登出后，再访问`/GET /user`就会跳转到`/user/login?path=%2Fuser`，登录后，跳转回去的功能请自行处理。


### 自定义登录认证

默认登录认证依赖于在用户会话中保存的变量，不过实际情况会比较复杂，比如禁止用户多端登录等等，系统无法直接提类似处理的配置，但开发者可以提供登录认证处理方法，来进行自定义的登录认证，注意，一旦设置后，默认的检查就不会被使用。

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        PLBR                    = {
            MySQL               = {
                host            = "127.0.0.1",
                port            = 3306,
                database        = "PLoop",
                user            = "admin",
                password        = "管理员密码",
                charset         = "utf8mb4",
                max_packet_size = 2 * 1024 * 1024,
            },
        },
        Validator               = {
            Login               = {
                LoginChecker    = function(context)
                    if context.Session.Items["userid"] ~= nil then
                        return true
                    else
                        return false
                    end
                end,
                LoginPage       = "/user/login",
                PathKey         = "path",
            }
        },
        ErrorHandler            = function(err, stack, context)
            context.Response.Write(err)
            context.Response:Close()
        end,
    }
end)
```

这个检查方法只有上下文对象作为参数，返回true代表用户登录认证通过。


### 权限认证

登陆后，我们需要根据功能的不同对用户进行鉴权，但权限系统应该由实际网站应用自行实现，所以，系统需要Web App自行提供权限认证处理，通常在配置文件中完成：

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        PLBR                    = {
            MySQL               = {
                host            = "127.0.0.1",
                port            = 3306,
                database        = "PLoop",
                user            = "admin",
                password        = "管理员密码",
                charset         = "utf8mb4",
                max_packet_size = 2 * 1024 * 1024,
            },
        },
        Validator               = {
            Login               = {
                Key             = "userid",
                LoginPage       = "/user/login",
                PathKey         = "path",

                AuthorityChecker= function (context, requirement, path)
                    local level = context.Session.Items.level or 0
                    if level >= requirement then
                        return true
                    else
                        return false, path or "/user/forbidden"
                    end
                end,
            }
        },
        ErrorHandler            = function(err, stack, context)
            context.Response.Write(err)
            context.Response:Close()
        end,
    }
end)
```

这里我们需要配置`Validator.Login.AuthorityChecker`，它的第一个参数是上下文对象，后面两个参数是之后`__Login__`配置的权限值，这里，我们使用`requirement`需求等级和`path`返回路径。

这个函数返回true说明鉴权通过，如果失败，需要返回一个路径作为重定向使用。

那么调整下控制器，看个例子（不重复已存在的代码）：

```lua
class "UserController" (function(_ENV)
    inherit "Controller"

    __Action__() __Login__(5)
    function noright(self, context)
    end

    __Action__() __Text__()
    function forbidden(self, context)
        return "你没有权限访问该资源"
    end
end)
```

登录后，访问`GET /user/noright`，会被重定向到`/user/forbidden`。用户权限具体检查需要Web App自行完成。`__Login__`仅仅用于提供配置方式。如果需要，也可以自行实现。


## 内部请求验证

实际网站构建中，我们会提供很多仅供内部请求访问的处理，通常我们需要使用`if context.IsInnerRequest then` 进行判定，但这样书写可能会出现书写错误，也不方便，所以系统提供了`__InnerRequest__`特性，如果不是内部请求的，直接返回404，拒绝请求。

```lua
class "UserController" (function(_ENV)
    inherit "Controller"

    __InnerRequest__()
    __Action__()
    function getentity(self, context)
        -- 省略
    end
end)
```

这个使用方式简单，这里不特意测试了。



## Http上下文请求处理流程

上面已经完整介绍了Web框架所提供的，可以直接应用于网站开发的功能。下面介绍的是框架开发部分，含请求处理器，自定义渲染引擎等。如无需要，可以停止阅读。

在上述处理Http请求的诸多类型中，路由，控制器，用户会话管理器等都扩展了`System.Web.IHttpContextHandler`接口，它们都是请求处理器，在流程的处理过程中，按照一定规则依次使用进行各种处理。

Http请求虽然由一个上下文对象进行管理，但它的处理流程完全由`IHttpContextHandler`接口定义，所有需要对请求进行处理的对象都必须直接或者间接的扩展这个接口，这个接口本身带有匿名类，所以，也可以直接用它定义新的请求处理器。

另外类似在路由文件中使用`__Text__`, `__Josn__`和`__View__`，它们内部定义了扩展这个接口的匿名类，目标函数会封装到这些匿名类的对象中实现处理。

下面是这个接口的具体定义：

```lua
--- 请求处理流程的阶段
__Flags__() __Sealed__()
enum "System.Web.IHttpContextHandler.ProcessPhase" {
    "Init",   -- 初始化
    "Head",   -- 处理和输出Http Head
    "Body",   -- 处理和输出Http Body
    "Final"   -- 处理结束后，回收资源，例如关闭缓存数据库连接等
}

--- 请求处理的优先级，每个阶段都需要根据优先级确定各个注册的中间件的使用顺序
__Sealed__() __Default__(0)
enum "System.Web.IHttpContextHandler.HandlerPriority" {
    Highest                 =  2,
    Higher                  =  1,
    Normal                  =  0,
    Lower                   = -1,
    Lowest                  = -2,
}
```

抽象属性                 |类型                   |默认值               |描述
:-----------------------|:----------------------|:-------------------|:--------------------
IsRequestHandler        |Boolean                |false               |该请求处理器是否会检查请求已处理标记，这个属性仅在初始化阶段使用，该属性为true的请求处理器通常会设置请求的`Handled`属性，一旦设置为true，其他会检查这个标记的都不会再执行操作，比如初始化时进行鉴权，失败，就标记该请求已处理，那么后续的路由处理等都不会再执行
ProcessPhase            |ProcessPhase           |Head + Body         |设置请求处理器作用的阶段，处理器仅在自己注册的阶段会被调用
Priority                |HandlerPriority        |Normal              |设置请求处理器的优先级，目前不支持分阶段设置优先级，如果需要，最好拆分成两个处理器
AsGlobalHandler         |Boolean                |false               |该请求处理器是否是全局使用，如果是，它会被用于处理所有的请求，不会被回收，例如路由管理器就是全局用
Application             |Application            |                    |读写该请求处理器绑定的Web App

抽象属性并不是一定需要被实现，通常都可以直接使用，仅仅是你覆盖后，不能也不需要访问超类属性。


抽象方法                 |参数                                        |描述
:-----------------------|:-------------------------------------------|:--------------------
Process                 |context: HttpContext, phase: ProcessPhase   |根据阶段执行请求

抽象方法必须被实现，虽然不是硬性要求，但不实现，也就没用处了。


方法                    |参数                                         |描述
:-----------------------|:-------------------------------------------|:--------------------
RegisterToContext       |context: HttpContext/nil                    |将自己注册到给定的或当前上下文，作为该上下文的临时请求处理器，典型的场景是路由加载特定的控制器文件，然后用对应的控制器类生成对象，再注册这个对象为临时请求处理器，之后它就可以处理请求，输出结果给客户端

通常请求处理器有三种：

* 临时请求处理器         - 例如在路由文件中直接使用`__Json__`等特性绑定函数生成的静态请求处理器，控制器，`.lsp`这类视图渲染类等，都是根据请求临时注册到上下文的，上下文处理结束，销毁后，注册也就被释放了

* Web App级全局处理器 - 注册为全局，并且指定了Web App的请求处理器，它们仅处理对应Web App的请求

* Server级全局处理器  - 没有指定Web App的全局请求处理器，它们会处理整个服务器上的所有请求，而不限于哪个Web App

以[NgxLua][]中，将Cookies写入客户端的Server级全局处理器为例：

```lua
-- the handler to send cookies
IHttpContextHandler {
        ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
        Priority        = IHttpContextHandler.HandlerPriority.Lowest,
        AsGlobalHandler = true,
        Process         = function(self, context, phase)
            if not context.IsInnerRequest then
                local cookies = context.Response.Cookies
                if next(cookies) then
                    local cache = {}
                    local cnt = 1
                    for name, cookie in pairs(cookies) do
                        cache[cnt] = tostring(cookie)
                        cnt = cnt + 1
                    end
                    ngx.header['Set-Cookie'] = cache
                end
            end
        end,
    }
```

下面是几个要点：

* 因为不涉及具体的Web App，这个请求处理器被用于所有Web App，将代码设置的Cookies输出给客户端。

* Cookies必须在发送Http Head给客户端前，输出出去，所以，必须在Head阶段完成，为了确保其他处理已经结束，它的优先级选择了最低。

* `IHttpContextHandler`具有匿名类，所以，可以直接用于构建对象，`Process`方法必须被实现。

* 注意`Process`中检查了`IsInnerRequest`，这是为了避免，向内部请求输出了Cookies，这没有意义，因为内部请求的存在，制作全局请求处理器时需要注意。

下面具体看请求的处理过程:

* Init    -- 初始化阶段，通常在此注册临时处理器
    * 执行Server级别的全局请求处理器
    * 执行App级别的全局请求处理器
* Head    -- Head输出阶段，用于产生Head的输出，例如结果的类型，Cookie信息等
    * 执行临时请求处理器
    * 执行App级别的全局请求处理器
    * 执行Server级别的全局请求处理器
    * 发送Head响应给客户端
* Body    -- Body输出阶段，用于产生Body的输出，例如JSON数据包，渲染的网页内容等，如果Head输出了重定向，那么本阶段不执行
    * 执行临时请求处理器
    * 执行App级别的全局请求处理器
    * 执行Server级别的全局请求处理器
    * 关闭请求，结束输出
* Final   -- 终止阶段，用于释放资源等
    * 执行临时请求处理器
    * 执行App级别的全局请求处理器
    * 执行Server级别的全局请求处理器


在控制器的代码中，我们一般使用`self:View(path, params)`输出结果，实际这个调用横跨了三个阶段：

* 当调用View方法时，首先将`text.html`输出类型及其他在调用View之前设置的头部信息（Cookie）写入输出

* 中断View方法的处理，调用交回`IHttpContextHandler`的`Process`方法，再发送了Head响应后，控制器对象在Body阶段唤醒View方法，继续处理

* View方法渲染页面，输出给客户端，然后再次中断自身

* `IHttpContextHandler`关闭请求后，进入终止阶段，控制器对象唤醒View方法

* View方法处理结束，将调用还给调用者及动作方法，这时候一般会执行后续的例如保存数据到缓存，关闭数据库等处理，这些处理不需要占用用户的等待时间。

这些实实际是控制器的实现细节，但使用时，通常不需要开发者注意这些。


## 错误处理

在之前的演示中，我们提供了错误处理，它可以有效的跟踪Lua文件代码，以及视图模板文件的错误，然后由Web App决定错误处理的方案。在上面的例子中，我们直接将错误输出到客户端，但结合上面对请求处理阶段的介绍，实际错误处理相对要复杂一些，下面是一个较为完整的做法。

下面的例子中，**不修改的部分不再重复，请自行对照修改例子**：

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    export { System.Web.IHttpContextHandler.ProcessPhase }

    _Config = {
        ErrorHandler            = function(err, stack, context)
            if not context.IsInnerRequest then
                -- 非内部请求时，要判定如何输出给客户端
                if context.ProcessPhase == ProcessPhase.Init or context.ProcessPhase == ProcessPhase.Head then
                    -- 此时可以显示错误页面给客户端
                    context:ProcessInnerRequest("/error", { error = err })
                    return context.Response:Close()
                elseif context.ProcessPhase == ProcessPhase.Body then
                    -- 如果已经开始输出文本，那么将错误信息同样输出，便于调试
                    -- 运营时，应使用error抛出给日志
                    context.Response.Write(err)
                    return context.Response:Close()
                end
            end

            -- 不论是终止阶段，还是内部请求，将错误抛出由外部处理，或者写入日志
            error(err, stack or 0)
        end,
    }
end)
```

```lua
-- /plbr/route.lua
Application "PLBR" (function(_ENV)
    __Route__ "/error" __Form__{ error = String }
    __View__ "error.view" [[
        <html>
            <head>
                <title>Error</title>
            </head>
            <body>
                <p>@self.error</p>
            </body>
        </html>
    ]]
    function errorhandler(context, form, err)
        return form
    end

    __Route__ "/{controller?|%a*}/{action?|%a*}/{id?|%d*}"
    function MVC(context, controller, action, id)
        controller = controller ~= "" and controller or "home"
        action     = action     ~= "" and action     or "index"
        id         = tonumber(id)

        return ("/controller/%scontroller.lua"):format(controller), { Action = action, ID = id }
    end
end)
```

随意添加一个错误，例如修改`user.view`:

**/html/view/index.view**:

```html
@{ master = "/share/global.master" }

@body{
    <p>用户名: @self.User.name</p>
    <p>手机号: @self.User.telno</p>
    <p>创建日期: @self.User.create:ToString()</p>

    <a href="/user/logout">登出</a>
}
```

这样访问时，错误发生在Body阶段，所以是直接输出:

```html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>My web site</title>
        <!-- javascript placeholder -->
    </head>
    <body>
        <p>用户名: abcd</p>
        <p>手机号: 13400000011</p>
        <p>创建日期: /root/www/html/view/user.view:6:  attempt to index field 'create' (a nil value)
```

通过位置，我们可以很快定义模板文件错误位置。还原模板，尝试在Head阶段出错，修改控制器文件：

```lua
-- /html/controller/usercontroller.lua
class "UserController" (function(_ENV)
    inherit "Controller"

    __Login__()
    __Action__("index", HttpMethod.GET)
    function index(self, context)
        with(UserDataContext())(function(ctx)
            local user = ctx.Uses:Query{ id = context.Session.Items.userid }:First()
            self:View("/view/user.view", { User = user })
        end)
    end
end)
```

Users错写成Uses，再次访问`GET /user`，可以得到:

```html
<html>
    <head>
        <title>Error</title>
    </head>
    <body>
        <p>/root/www/html/controller/usercontroller.lua:30: attempt to index field 'Uses' (a nil value)</p>
    </body>
</html>
```

那么我们得到了完整的错误页面输出。如果使用按照需求来即可。



## 相对路径和绝对路径

在上面的例子中，涉及访问其他文件的地方都牵扯到绝对路径（以/开始）和相对路径。总结一下：

* 根路径/对应的硬盘路径会从`context.Request.Root`读取，也就是在`nginx.conf`中设置的Root位置

* 在指定文件路径时，以`/`开始的时绝对路径，即合并根路径和指定文件路径后得到目标文件路径

* 在指定文件路劲时，不以`/`开始的是相对路径，以当前文件所在目录和指定文件路径合并后得到目标文件路径（允许使用`..`指向上层目录）



## 视图的配置

在每个视图模板文件中，首行一般是配置table，这个配置和使用的渲染引擎无关。在上面的例子中，使用了`master`, `helper`, `code`这些配置。

实际上，我们还可以为视图模板文件提供基于Web App的默认配置，视图文件自带的配置会覆盖默认配置，通过这个默认配置，我们可以了解下，都有哪些可以使用：

```lua
_Config = {
    View                    = {
        Default             = {
            master          = nil,     -- 指定给视图模板文件的母模板，这里通常不会指定
            helper          = nil,     -- 指定给视图模板文件的帮助文件，这里通常不会指定
            reload          = nil,     -- 指定是否重新加载模板文件，如果文件被修改了，一般不设置，走服务器配置的Debug，请注意无论设为true还是false，Debug设置都不再有效
            encode          = true,    -- 指定是否对所有模板输出的表达式做转码，如果担心开发者漏写，可以开启，相对消耗大些
            noindent        = true,    -- 禁止缩进，系统会在生成渲染类时，删除掉所有的缩进处理，可以有效的提高输出性能，并且减少传输给客户端的大小，仅推荐发布时使用
            nolinebreak     = true,    -- 禁止换行，系统会在生成渲染类时，删除掉所有的换行，提升效率，减少传输文本长度，请注意，页面上使用JS代码时，务必使用`;`号等间隔行，避免合并后出现问题
            linebreak       = "\n",    -- 设置换行字符
            engine          = nil,     -- 默认渲染引擎，通常不设置，但如果打算自定义渲染引擎，这里可以替换掉系统使用的System.Web.PageRenderEngine
            asinterface     = nil,     -- 以接口形式生成文件结果，目前只有`.helper`需要使用这个配置，所以这里不设置
            export          = {        -- 导出特殊的一组函数，可以在视图模板中直接使用它们
                error       = function(message, target)
                    return Struct.GetErrorMessage(message, target)
                end,
            },
        },

        -- 注意上面的Default，那是所有视图模板通用的配置，而不在意模板类型
        -- 我们还可以更精确的对特定视图模板类型进行配置，ViewPage是针对所有的`.view`文件
        -- 另外，文件本身的配置是最优先，会覆盖这里的配置
        ViewPage             = {
            reload           = true,
        },
    },
}
```

下面是所有视图模板类型，以及它继承的超类（以超类的配置做自己的默认配置）：

名字             |超类                  |文件后缀                |描述
:----------------|:---------------------|:---------------------|:--------------------------------
Default          |                      |.*                    |所有模板通用
HtmlPage         |Default               |.*                    |所有HTML模板通用
StaticFile       |Default               |.*                    |所有静态文件通用
ViewPage         |HtmlPage              |.view                 |View文件通用
EmbedPage        |HtmlPage              |.embed                |嵌入视图文件通用
PageHelper       |HtmlPage              |.helper               |帮助文件通用
LuaServerPage    |HtmlPage              |.lsp                  |LSP文件通用
MasterPage       |HtmlPage              |.master               |母模板文件通用
CssFile          |StaticFile            |.css                  |CSS文件通用
JavascriptFile   |StaticFile            |.js                   |JS文件通用

修改我们的配置文件如(其他部分保留，仅添加)

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    _Config = {
        View                    = {
            Default             = {
                noindent        = true,
                nolinebreak     = true,
            },
        },
    }
end)
```

然后访问`GET /user`可以看到结果为：

```html
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>My web site</title><!-- javascript placeholder --></head><body><p>用户名: abcd</p><p>手机号: 13400000011</p><p>创建日期: 2019-11-05 20:47:26</p><a href="/user/logout">登出</a></body></html>
```

可见，缩进和换行都没有了。请注意，如果使用这个模式输出，JS的换行必须带有`;`号，注释需要使用`/* xxxx */`的形式，才能确保单行输出时，不会出现问题。



## 自定义渲染引擎

**PLoop**仅提供了两个渲染引擎`System.Web.IRenderEngine`对应静态文件，以及`System.Web.PageRenderEngine`对应我们的视图模板文件。

但**PLoop**提供了自定义渲染引擎的接口，首先，我们看以下静态文件渲染引擎的实现：

```lua
namespace "System.Web"

--- 渲染转换为代码的规则
__Sealed__() __AutoIndex__()
enum "RenderContentType" {
    "RecordLine",
    "StaticText",
    "NewLine",
    "LuaCode",
    "Expression",
    "EncodeExpression"
    "MixMethodStart",
    "MixMethodEnd",
    "CallMixMethod",
    "RenderOther",
    "InnerRequest",
}

__Sealed__() __AnonymousClass__()
interface "IRenderEngine"(function (_ENV)
    extend "Iterable"

    -- 这个方法已经实现，所以，不需要也最好不要覆盖
    __Iterator__()
    function GetIterator(self, reader) return self:ParseLines(reader) end

    -- 根据文件配置（以文件类型对应的配置和默认配置为基础）进行初始化
    __Abstract__() function Init(self, loader, config) end

    --- 从流读取对象中，解析所有输出的行，并且返回所有的渲染处理动作
    -- 实际，就是利用RenderContentType指定的规则，生成渲染类
    __Abstract__() function ParseLines(self, reader)
        local yield = coroutine.yield

        -- 使用yield可以很好的保持处理的上下文

        -- 首先，每个渲染类都应该定义或继承（通过母模版）到一个Render方法，这个是渲染的起点
        yield(RenderContentType.MixMethodStart, "Render")

        for line in reader:ReadLines() do
            line = line:gsub("%s+$", "")

            -- 每读取到一行，都需要先使用RecordLine记录行号，
            -- 这样系统才能在渲染类出错时，将两边的行号对应起来，给出错误位置
            yield(RenderContentType.RecordLine, line)

            -- 因为是静态文件，直接将文本行作为静态文本输出即可
            yield(RenderContentType.StaticText, line)

            -- 最后给一个换行，这样可以形成良好的显示风格
            -- 缩进是自动处理，无需引擎处理
            yield(RenderContentType.NewLine)
        end

        -- Render方法定义结束
        yield(RenderContentType.MixMethodEnd)

        -- 文件解析结束，之后系统会根据配置情况自动生成类型
    end
end)
```

如果要自定义一个渲染引擎，需要扩展`IRenderEngine`接口，并自行实现两个方法

抽象方法            |参数                                             |描述
:------------------|:------------------------------------------------|:-------------------------
Init               |loader: IOutputLoader, config: RenderConfig      |使用文件加载器（通常不用在意）和配置（例如读取config.noindent)进行初始化，一般很少需要实现这个方法
ParseLines         |reader: TextReader                               |从流读取对象中获取所有行，并根据文本通过yield返回渲染动作和参数

下面是RenderContentType定义的渲染动作和参数：

动作                |参数                                                             |描述
:------------------|:----------------------------------------------------------------|:------------------------------------
RecordLine         |line:String                                                      |记录当前行，这样系统可以将转换后代码的错误行和定义行对应
StaticText         |text:String                                                      |输出静态文本
NewLine            |                                                                 |输出换行
LuaCode            |line:String                                                      |输出Lua代码，比如 `if xxx then`
Expression         |exp:String                                                       |输出表达式
EncodeExpression   |exp:String                                                       |输出需要转码的表达式
MixMethodStart     |name:String                                                      |开始混合方法的定义，web部件实际也是混合方法，实际就是类的方法，只不过具有特殊处理
MixMethodEnd       |                                                                 |结束混合方法的定义
CallMixMethod      |name:String, params:String, default:String, issupercall:Boolean  |调用混合方法，如果未定义，输出默认值，如果指定issupercall，调用母模版的处理，类似`@{suepr:body}`
RenderOther        |path:String, params:String, default:String                       |渲染其他文件，例如`@[/share/notice.embed]`
InnerRequest       |url:String, params:String                                        |执行内部请求

下面是一个相对复杂的例子，我们定义了一个新的模板，以及新的格式：

**/html/view/index.wf**

```html
html
    head
        title
            > my web site
    body
        div #mainDiv .center
            p #random style='width:100px'
                > random is {{ math.random(10000) }} pts
```

我们需要定义两个类，一个是解析这个模板的引擎，另一个是文件加载类，先加入文件引用

```lua
-- /plbr/init.lua
Application "PLBR" (function(_ENV)
    namespace "PLBR"

    class "HttpContext" {
        NgxLua.HttpContext,
        __ctor = function(self) self.Application = _ENV end
    }

    -- 会话ID管理器
    NgxLua.JWTSessionIDManager{ CookieName = "PLBR_JWT", TimeoutMinutes = 1 * 24 * 60, Application = _ENV }

    -- 会话存储管理器
    NgxLua.JWTSessionStorageProvider{ Application = _ENV }
end)

import "PLBR"

-- 加载数据模型文件
require "plbr.database"

-- 加载新模板类型
require "plbr.waterfall"

-- 加载路由文件
require "plbr.route"

-- 加载配置文件
require "plbr.config"
```

然后创建：

```lua
-- /plbr/waterfall.lua
Application "PLBR"(function(_ENV)
    import "System.IO.Resource"
    import "System.Web"

    -- 定义渲染引擎
    class "WaterFallEngine"(function (_ENV)
        extend "IRenderEngine"

        local yield     = coroutine.yield

        local NOT_CHILD = 0
        local NODE_ELE  = 1
        local TEXT_ELE  = 2

        local function parseLine(self, reader, chkSpace, isFirstChild)
            line = self.CurrentLine or reader:ReadLine()

            self.CurrentLine = nil

            if not line then return NOT_CHILD end
            line = line:gsub("%s+$", "")

            yield(RenderContentType.RecordLine, line)

            local space, tag, ct = line:match("^(%s*)(%S+)%s*(.*)$")

            space = space or ""

            if tag == ">" then
                -- 显示文本
                -- 例如 "random is {{ math.random(10000) }} pts"
                local startp = 1
                local expSt, expEd = ct:find("{{.-}}", startp)

                while expSt do
                    -- "random is "是静态文本
                    yield(RenderContentType.StaticText, ct:sub(startp, expSt - 1))

                    -- math.random(10000) 是表达式
                    yield(RenderContentType.Expression, ct:sub(expSt + 2, expEd - 2))

                    startp = expEd + 1
                    expSt, expEd = ct:find("{{.-}}", startp)
                end

                -- 剩下的" pts"也是静态文本
                yield(RenderContentType.StaticText, ct:sub(startp))

                return TEXT_ELE
            end

            -- 检查是否是子节点
            if not chkSpace or #space > #chkSpace then
                -- 如果是子节点
                -- for "        div #mainDiv .center"

                if chkSpace then
                    if isFirstChild then
                        -- 如果是子节点，并且是第一个元素，需要先增加一个新行
                        yield(RenderContentType.NewLine)
                    end

                    -- "        "空白也是静态文本，也需要输出（不然系统无法确保缩进）
                    yield(RenderContentType.StaticText, space)
                end

                -- 获取id，class和其他属性
                local id, cls = "", ""
                local cache = { tag }

                -- 获取并移除id
                ct = ct:gsub("#(%w+)", function(w) id = w return "" end)
                if #id > 0 then
                    table.insert(cache, ([[id="%s" name="%s"]]):format(id, id) )
                end

                -- 获取并移除class
                ct = ct:gsub("%.(%w+)", function(w) cls = cls .. w .. "," return "" end)
                if #cls > 0 then
                    table.insert(cache, ([[class="%s"]]):format(cls:sub(1, -2)) )
                end

                -- 获取剩下的属性
                ct = ct:gsub("^%s*(.-)%s*$", "%1")
                if ct and #ct > 0 then
                    table.insert(cache, ct)
                end

                -- "div #mainDiv .center" -> 静态文本 : <div id="mainDiv" name="mainDiv" class="center">
                yield(RenderContentType.StaticText, "<" .. table.concat(cache, " ") .. ">")

                --  检查下一行
                local firstNode = true

                while true do
                    local ret = parseLine(self, reader, space, firstNode)

                    firstNode = false

                    if ret == TEXT_ELE then
                        -- 关闭HTML标签
                        yield(RenderContentType.StaticText, "</" .. tag .. ">")

                        -- 产生一个新行
                        yield(RenderContentType.NewLine)

                        return NODE_ELE
                    elseif ret == NODE_ELE then
                        -- 继续处理子节点
                    else
                        -- 到达节点的最后
                        if #space > 0 then
                            yield(RenderContentType.StaticText, space)
                        end

                        -- 关闭标签
                        yield(RenderContentType.StaticText, "</" .. tag .. ">")

                        -- 产生一个新行
                        yield(RenderContentType.NewLine)

                        return NODE_ELE
                    end
                end
            else
                -- 这不是一个子节点，返回NOT_CHILD关闭之前的节点
                self.CurrentLine = line

                return NOT_CHILD
            end
        end

        function ParseLines(self, reader)
            yield(RenderContentType.MixMethodStart, "Render")

            parseLine(self, reader)

            yield(RenderContentType.MixMethodEnd)
        end
    end)

    -- 定义视图文件加载类，并绑定后缀名，功能主要由`__PageRender__`完成，
    -- 之后在`_Config.View`中，可以为`WaterFallPage`单独定义配置
    -- 注意最后的{ engine = WaterFallEngine }是为`WaterFallPage`指定默认配置
    -- 这里就是指定了渲染引擎
    __ResourceLoader__"wf"   -- Register for the .wf files
    __PageRender__("WaterFallPage", IOutputLoader, { engine = WaterFallEngine })
    class "System.Web.WaterFallPage" { IOutputLoader }

    -- 简单起见，做个路由
    __Route__ "/index"
    __View__ "/view/index.wf"
    function index(context)
        return { name = "Ann" }
    end
end)
```

为了检查生成的渲染类，我们可以打开临时目录设置:

```lua
-- /plbr/config.lua
Application "PLBR" (function(_ENV)
    export { System.Web.IHttpContextHandler.ProcessPhase }

    _Config = {
        View                = {
            Temporary       = "/temp",
        },
    }
end)
```

请创建`~/www/html/temp`目录，这个目录将存有视图文件转换成的代码

那么，重启nginx，访问`GET /index`，可以得到：

```html
<html>
    <head>
        <title>my web site</title>
    </head>
    <body>
        <div id="mainDiv" name="mainDiv" class="center">
            <p id="random" name="random" style='width:100px'>random is 2377 pts</p>
        </div>
    </body>
</html>
```

打开`/html/temp/index.wf.lua`文件，这就是我们渲染类的内部代码：

```lua
local _PL_HtmlEncode, tostring, select = System.Web.HtmlEncode, System.Web.ParseString, select

function Render(self, _PL_write, _PL_indent)
    _PL_indent = _PL_indent or ""
    _PL_write(_PL_indent)
    _PL_write("<html>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9")
    _PL_write("<head>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9\9")
    _PL_write("<title>")
    _PL_write("my web site")
    _PL_write("</title>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9")
    _PL_write("</head>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9")
    _PL_write("<body>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9\9")
    _PL_write("<div id=\"mainDiv\" name=\"mainDiv\" class=\"center\">")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9\9\9")
    _PL_write("<p id=\"random\" name=\"random\" style='width:100px'>")
    _PL_write("random is ")
    _PL_write(tostring( math.random(10000) ))
    _PL_write(" pts")
    _PL_write("</p>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9\9")
    _PL_write("</div>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("\9")
    _PL_write("</body>")
    _PL_write("\n")
    _PL_write(_PL_indent)
    _PL_write("</html>")
end
```

配合这个temp文件，可以检查引擎的工作情况。当然，相对有些复杂，如无必要，默认引擎也足够使用了。

[PLoop.Browser]: https://github.com/kurapica/PLoop.Browser  "PLoop Lib Browser"
[nginx]: https://www.nginx.com/ "Nginx"
[Openresty]: https://github.com/openresty/lua-nginx-module/ "Openresty"
[NgxLua]: https://github.com/kurapica/NgxLua/ "An implementation for the Openresty"