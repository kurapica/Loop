# System.Net.MQTT

The MQTT Lib support MQTT v3.1(3), v3.1.1(4) and v5.0(5), it works with the [LuaSocket][].
With the [NgxLua][] it also support building MQTT services within the [OpenResty][].


## Start with an example with MQTT server and client
----

This example require [LuaSocket][] to be run.

```lua
--- MQTT services
-- MQTT lib is standalone, so should be required first
require "PLoop.System.Net.MQTT"

PLoop(function(_ENV)
    import "System.Net"
    import "System.Net.MQTT"

    -- with trace logger, the details will be print out, also you can turn it to
    -- Logger.LogLevel.Info for simple
    Logger.Default:AddHandler(print)
    Logger.Default.LogLevel = Logger.LogLevel.Trace

    -- System.Net.MQTT.Server provide the mqtt services
    -- Use `with` pattern to make sure it can be closed without error
    -- Don't need set the mqtt protocol level, since the server can handle
    -- all three protocol levels
    with(Server{ ReceiveTimeout = 1, Port = 3000 })(function(server)
        while true do
            -- This is a simple example, so only works for one client
            -- Get the client and process with operations with the client
            with(server:GetClient())(function(client)
                local topic

                -- The OnTopicSubscribed event can be used to handle the subscribed topic
                -- The client can use a message publisher to handle the pub/sub jobs automatically
                -- But we may need handle it for special usages
                function client:OnTopicSubscribed(t)
                    print("OnTopicSubscribed", t)
                    topic           = t
                end

                -- The OnMessageReceived event fired when the client publish a message to the server
                function client:OnMessageReceived(topic, payload)
                    print("[PAYLOAD]", payload)
                end

                -- This is the main logic, the Process is a loop until the connection is closed
                -- It'll receive the packete from the client and answer it automatically, it'll also
                -- check the subscribed topic and send the published message of the topic to the client
                --
                -- You can also create your own Process logic, we'll see it later
                client:Process()
            end, function(err)
                print("The client is closed:", tostring(err))
            end)
        end
    end, function(err)
        print(err)
    end)
end)
```

```lua
-- MQTT Client
require "PLoop.System.Net.MQTT"

PLoop(function(_ENV)
    import "System.Net"
    import "System.Net.MQTT"

    Logger.Default:AddHandler(print)
    Logger.Default.LogLevel = Logger.LogLevel.Trace

    -- Use MQTT v3.1.1 version
    local client = Client{ Address  = "127.0.0.1",  ProtocolLevel = 4, Port = 3000 }

    local ok, err = pcall(function()
        print("Connecting ...")
        if client:Connect() then
            print("Connection established")

            client:Subscribe("/topic")

            for i = 1, 3 do
                print("Sleep 5 sec")

                -- the client.Socket is the System.Net.Socket based on LuaSocket
                -- So we can use it to sleep
                client.Socket:Sleep(5)

                print("Publish message")
                client:Publish("/topic", [[{"station_name":"test","real_data",[{"tag_desc":"liquid","value":"1.350"},{"tag_desc":"pressure","value":"3.600"}]], 1, true)

                -- We can get the next packet and its type through the ParsePacket method
                local ptype, packet = client:ParsePacket()
                if ptype then
                    print(PacketType(ptype), Toolset.tostring(packet))

                    -- The ProcessPacket can handle the packet automatically and send the response to the server
                    -- The Process method of server is done by ParsePacket and ProcessPacket
                    client:ProcessPacket(ptype, packet)
                end
            end

            client:DisConnect()
        end
    end)

    print(err)
end)
```


The MQTT is a big topic to be discussed, in this chapter, we'll cover the normal usages.


## System.Net.MQTT.Client

This is the basic mqtt client class, it provide the basic MQTT operations no matter where or which platform you use it.

There are two types of the client:

1. The client used to connect the server, we create that in the previous example like `local client = Client{ Address  = "127.0.0.1",  ProtocolLevel = 4, Port = 3000 }`.

2. The client that returned by the server's Accept method, we get that in previous example like `server:GetClient()`.

Although they all represents the client, they use different methods, and the data transmission is opposite.

In the previous examples, the client-side client used `Subscribe` to subscribe topics, use `Publish` to publish message to server,
and the `ProcessPacket` to handle any packet you don't want handled manually, we'll see the full list later.



## System.Net.MQTT.Server

Unlike the Client, the server class defined in `System.Net.MQTT` is just an implementation based on [LuaSocket][], and normally it's
only used to handle one client at the same time. We already see how to use it in the example.

With [NgxLua][] and [OpenResty][] we can build a full functional MQTT server, but there is no MQTTServer class defined, we only need
use the `NgxLua.Net.MQTT.Client` to handle the MQTT clients. So we won't discuss the server any more.



## MQTT Enums
----

Here are some main enums, there are many other enums could be used but you should check them in [MQTT Core][].

**System.Net.MQTT.ProtocolLevel** - The MQTT Protocol Level for different version

* V3_1      - 3, the MQTT v3.1
* V3_1_1    - 4, The MQTT v3.1.1
* V5_0      - 5, The MQTT v5.0


**System.Net.MQTT.PacketType** - The MQTT packet type


* FORBIDDEN     - 0,  unexpected type
* CONNECT       - 1,  the connection data packet
* CONNACK       - 2,  the connection ack data packete
* PUBLISH       - 3,  the publish message data packet
* PUBACK        - 4,  the publish message ack data packet
* PUBREC        - 5,  the publish message receive data packet
* PUBREL        - 6,  the publish message release data packet
* PUBCOMP       - 7,  the publish message complete data packet
* SUBSCRIBE     - 8,  The topic subscribe data packet
* SUBACK        - 9,  the topic subscribe ack data packet
* UNSUBSCRIBE   - 10, the topic unsubscribe data packet
* UNSUBACK      - 11, the topic unsubscribe ack data packet
* PINGREQ       - 12, the ping request data packet
* PINGRESP      - 13, the ping response data packet
* DISCONNECT    - 14, the disconnect data packete
* AUTH          - 15, The auth data packet, For MQTT v5.0


**System.Net.MQTT.QosLevel** - The message QoS level

* AT_MOST_ONCE  - 0, No ack for the published message
* AT_LEAST_ONCE - 1, Need return ack for the published message
* EXACTLY_ONCE  - 2, Need use PUBREC -> PUBREL -> PUBCOMP to confirm the message


We'll discuss the MQTT protocol by the packet types.


## CONNECT
----





## Running A MQTT Service

Before creating the MQTT service, you could follow the guide in the [020.web.md - Test Environment](./020.web.md#test-environment).


[MQTT Core]: ../System/Net/MQTT/Core.lua "MQTT Core"
[LuaSocket]: http://w3.impa.br/~diego/software/luasocket/tcp.html "LuaSocket"
[Openresty]: https://github.com/openresty/lua-nginx-module/ "Openresty"
[NgxLua]: https://github.com/kurapica/NgxLua/ "An implementation for the Openresty"