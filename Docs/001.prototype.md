# prototype

The **prototype** provided a system to build prototypes of others. It's the basic system of the **PLoop**.

**You can skip this chapter if you only care about the object-oriented program system.**

The **prototype** is designed based on the Lua's meta-table system with the *newproxy* api(The system will provide an alternative if not existed).

In **PLoop** there are many prototypes, the **class** prototype used to create classes, the **environment** prototype used to generate environments used as type builders or modules.


## Table of Contents

* [The creation of a prototype](#the-creation-of-a-prototype)
* [Super prototype](#super-prototype)
* [The controllable `__index`](#the-controllable-__index)
* [System.Prototype](#systemprototype)
	* [GetMethods](#getmethods)
	* [NewProxy](#newproxy)
	* [NewObject](#newobject)
	* [ValidateValue](#validatevalue)
	* [Validate](#validate)


## The creation of a prototype

A prototype is an userdata(if *newproxy* existed) or a table(without *newproxy*) with specific meta-table settings.

Here is an example to show how to create and use a prototype within the **PLoop** :

```lua
require "PLoop"

proxy = prototype {
	__index = function(self, key) return rawget(self, "_" .. key) end,
	__newindex = function(self, key, value) rawset(self, "_" .. key, value) end,
}

obj = prototype.NewObject(proxy)
obj.Name = "Test"

-- Test Test
print(obj.Name, obj._Name)
```

* The **prototype** is used to generate the prototype based on the meta-table settings.

* There is no restriction for meta-table settings, the system don't need all prototypes to be **prototype**s, many of them are designed for special using.

* There are two extra rules besides the Lua's meta-table settings:
	* `__metatable`: if omit, the generated prototype will be used, so `getmetatable(prototype)` will return itself.
	* `__tostring` : if it is a string, `tostring(prototype)` will return that string, just for simple.

* The generated prototype can provide features by itself, or define features for objects generated by it, we can use `prototype.NewObject` API to generate the objects(table) of the prototype.

* Since the prototype are expected as userdata, we shouldn't save/get the data on it directly(like table), so the *proxy* is only used to define features for its objects.


## Super prototype

We can create a new prototype based on a super prototype :

```lua
require "PLoop"

proxy = prototype {
	__index = function(self, key) return rawget(self, "_" .. key) end,
	__newindex = function(self, key, value) rawset(self, "_" .. key, value) end,
}

cproxy = prototype (proxy, { __call = function(self) print("Hi " .. self.Name) end })

obj = prototype.NewObject(cproxy)
obj.Name = "Test"

-- Hi Test
obj()
```

The new prototype will try to copy all meta-table settings(exclude the `__metatable`) from the super prototype if it don't have.

If the two prototype both use tables as `__index`, the contents will also be copied:

```lua

require "PLoop"

person = prototype {
	__index = {
		setName = function(self, name) self[0] = name end,
		getName = function(self) return self[0] end,
	}
}

student = prototype (person, {
	__index = {
		setScore = function(self, score) self[1] = score end,
		getScore = function(self) return self[1] end,
	}
})

obj = prototype.NewObject(student)

obj:setName("Ann")
obj:setScore(90)

-- My name is Ann, my score is 90
print(("My name is %s, my score is %d"):format(obj:getName(), obj:getScore()))
```

## The controllable `__index`

The table contains the meta-table settings won't be used as the meta-table directly to avoid change the meta-table settings dynamically.

If the `__index` is a table, it also can't be used directly:

```lua
require "PLoop"

local indextbl = { a = 1, b = 2 }

person = prototype { __index = indextbl }

indextbl.c = 3,

-- 1    nil
print(person.a, person.c)
```

But if you really need the `__index` to be controllable, you can force it like :

```lua
require "PLoop"

local indextbl = { a = 1, b = 2 }

person = prototype ({ __index = indextbl }, true)

indextbl.c = 3

-- 1    3
print(person.a, person.c)
```

So, after the meta-table settings, you can use the *true* parameter to force the prototype use it directly.


## System.Prototype

The **System.Prototype** is a child-prototype of the **prototype** itself, it's registered to the **PLoop**'s namespace system, so we can easily access it, it contains all methods of the prototype system.


### GetMethods

Get the methods of the prototype, only works if the `__index` is a table.

* Params:
	* prototype     - the prototype
* Return
	* iterator      - function, the iterator to get all methods
	* target        - the target prototype

```lua
require "PLoop"

PLoop(function(_ENV)
	person = prototype ({
		__index = {
			testA = function() end,
			testB = function() end,
		},
	}, true)

	for k in Prototype.GetMethods(person) do
		print(k)
	end
end)
```


### NewProxy

Create a proxy with the prototype's meta-table, it's the same function of newproxy.

* Params:
	* prototype     - the prototype
* Return
	* proxy         - userdata, the userdata with the same meta-table of the prototype


### NewObject

Create a table(object) with the prototype's meta-table

* Format: (prototype[, object])
* Params:
	* prototype - the prototype
	* object        - the table will be set the meta-table
* Return
	* object        - table, the table with the same meta-table of the prototype


### ValidateValue

Whether the value is an object(proxy) of the prototype(has the same meta-table), only works for the prototype that use itself as the `__metatable`.

* Format: (prototype, value[, onlyvalid])
* Params:
	* prototype     - the prototype
	* value         - table|userdata, the target value
	* onlyvalid     - boolean, true if don't need an error message
* Return
	* value         - the validated value, nil if not valid
	* message       - boolean|string, the error message or true if onlyvalid is true


### Validate

Whether the value is a prototype

* Params:
	* target        - the target
* Return
	* isprototype   - boolean, whether the target is a prototype